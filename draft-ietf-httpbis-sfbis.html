<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Structured Field Values for HTTP</title>
<meta content="Mark Nottingham" name="author">
<meta content="Poul-Henning Kamp" name="author">
<meta content='
       This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values. 
       This document obsoletes RFC 8941. 
    ' name="description">
<meta content="xml2rfc 3.25.0" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-ietf-httpbis-sfbis-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.25.0
    Python 3.12.7
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.4
    lxml 5.3.0
    platformdirs 4.3.6
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.32.3
    setuptools 70.3.0
    wcwidth 0.2.13
-->
<link href="draft-ietf-httpbis-sfbis.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  --font-title: "Sofia Sans Semi Condensed", sans-serif;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
section {
  clear: both;
}
.section-number {
  padding-right: 0.5em;
}
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-title);
  font-weight: 680;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
  vertical-align: top;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
  & :is(ol, ul) {
    margin-left: 1em;
  }
}
li {
  margin: 0 0 0.25em 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
  & li {
    margin-top: 0.5em;
  }
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  margin: 0 0 0 2em;
  & li {
    margin: 0;
    & :first-child { margin-top: 0; }
    & :last-child { margin-bottom: 0; }
  }
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
  &.olPercent {
    --indent: 5ch;
    & > dt {
      min-width: calc(var(--indent) - 2ch);
    }
  }
  &.olPercent > dt {
    float: none;
  }

  dl > dd > & {
    margin-top: 0.5em;
    margin-bottom: 0;
  }
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
  & > :is(:first-child, .break:first-child + *) {
    margin-top: 0;
  }
  & > :is(:last-child) {
    margin-bottom: 0;
  }
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
  caption-side: bottom;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: auto;
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
  &[href] {
    color: var(--pilcrow-weak);
    &:hover { text-decoration: none; }
  }
}
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
  & dt {
    width: var(--identifier-width);
    min-width: var(--identifier-width);
    clear: left;
    float: left;
    text-align: right;
    margin-right: 1ch;
  }
  & dd {
    margin: 0;
    margin-left: calc(1em + var(--identifier-width)) !important;
    min-width: 5em;
  }
  & .authors {
    & .author {
      display: inline-block;
      margin-right: 1.5em;
    }
    & .org {
      font-style: italic;
    }
  }
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;

  & nav {
    & ul {
      margin: 0 0.5em 0 0;
      padding: 0;
      list-style: none;
    }
    & li {
      line-height: 1.3em;
      margin: 2px 0;
      padding-left: 1.2em;
      text-indent: -1.2em;
    }
  }
  & a.xref {
    white-space: normal;
  }
}

.references {
  & > dt {
    text-align: right;
    font-weight: bold;
    min-width: 10ch;
    margin-right: 1.5ch;
    &:target::before {
      content: "⇒";
      margin: 0 10px 0 -25px;
    }
  }
  & > dd {
    margin-left: 12ch !important;
    overflow: visible;
    & .refInstance {
      margin-bottom: 0.8em;
    }
    & .ascii {
      margin-bottom: 0.25em;
    }
  }
}

#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  max-width: 20em;
  margin: 1em auto 1em 0;

  & .nameRole {
    font-weight: 700;
    margin-left: 0;
  }
  & .label {
    margin: 0.5em 0;
  }
  & .type {
    display: none;
  }
  & .alternative-contact {
    margin: 0.5em 0 0.25em 0;
  }
  & .non-ascii {
    margin: 0 0 0 2em;
  }
  & div.left {
    text-align: left;
  }
  & div.right {
    text-align: right;
  }
}

hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

/* Comments */
.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}

@media screen {
  #toc nav {
    font-family: var(--font-title);
    font-weight: 360;
    & > ul { margin-bottom: 2em; }
    & ul {
      margin: 0 0 0 4px;
      & :is(p, li) {
        margin: 2px 0;
      }
    }
  }
  #toc a.toplink {
    float: right;
  }
}
@media not screen {
  #toc a.toplink {
    display: none;
  }
}


/* TOC layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
    &::before { /* css hamburger */
      float: right;
      position: relative;
      width: 1em;
      height: 1px;
      left: -164px;
      margin: 8px 0 0 0;
      background: white none repeat scroll 0 0;
      box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
      content: "";
    }
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active {
    opacity: 1;
    & nav { display: block; }
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:is(:link, :focus, :hover),
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin: 2px 0.5em 0;
  }
}

/* TOC layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
  #toc a.toplink {
    margin: 8px 0.5em 0;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">Structured Field Values for HTTP</td>
<td class="right">December 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Nottingham &amp; Kamp</td>
<td class="center">Expires 11 June 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">HTTP</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-httpbis-sfbis-latest</dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc8941" class="eref">8941</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-12-08" class="published">8 December 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-06-11">11 June 2025</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">M. Nottingham</div>
<div class="org">Cloudflare</div>
</div>
<div class="author">
      <div class="author-name">P.-H. Kamp</div>
<div class="org">The Varnish Cache Project</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Structured Field Values for HTTP</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">This document obsoletes RFC 8941.<a href="#section-abstract-2" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-sfbis/">https://datatracker.ietf.org/doc/draft-ietf-httpbis-sfbis/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">
        Discussion of this document takes place on the
        HTTP Working Group mailing list (<span><a href="mailto:ietf-http-wg@w3.org">mailto:ietf-http-wg@w3.org</a></span>),
        which is archived at <span><a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a></span>.
        Working Group information can be found at <span><a href="https://httpwg.org/">https://httpwg.org/</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
<p id="section-note.1-4">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/httpwg/http-extensions/labels/header-structure">https://github.com/httpwg/http-extensions/labels/header-structure</a></span>.<a href="#section-note.1-4" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 11 June 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-intentionally-strict-proces" class="internal xref">Intentionally Strict Processing</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-notational-conventions" class="internal xref">Notational Conventions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-defining-new-structured-fie" class="internal xref">Defining New Structured Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="auto internal xref">2.1</a>.  <a href="#name-example" class="internal xref">Example</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="auto internal xref">2.2</a>.  <a href="#name-error-handling" class="internal xref">Error Handling</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="auto internal xref">2.3</a>.  <a href="#name-preserving-extensibility" class="internal xref">Preserving Extensibility</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="auto internal xref">2.4</a>.  <a href="#name-using-new-structured-types-" class="internal xref">Using New Structured Types in Extensions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-structured-data-types" class="internal xref">Structured Data Types</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-lists" class="internal xref">Lists</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.1">
                    <p id="section-toc.1-1.3.2.1.2.1.1"><a href="#section-3.1.1" class="auto internal xref">3.1.1</a>.  <a href="#name-inner-lists" class="internal xref">Inner Lists</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.2">
                    <p id="section-toc.1-1.3.2.1.2.2.1"><a href="#section-3.1.2" class="auto internal xref">3.1.2</a>.  <a href="#name-parameters" class="internal xref">Parameters</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-dictionaries" class="internal xref">Dictionaries</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-items" class="internal xref">Items</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.1">
                    <p id="section-toc.1-1.3.2.3.2.1.1"><a href="#section-3.3.1" class="auto internal xref">3.3.1</a>.  <a href="#name-integers" class="internal xref">Integers</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.2">
                    <p id="section-toc.1-1.3.2.3.2.2.1"><a href="#section-3.3.2" class="auto internal xref">3.3.2</a>.  <a href="#name-decimals" class="internal xref">Decimals</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.3">
                    <p id="section-toc.1-1.3.2.3.2.3.1"><a href="#section-3.3.3" class="auto internal xref">3.3.3</a>.  <a href="#name-strings" class="internal xref">Strings</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.4">
                    <p id="section-toc.1-1.3.2.3.2.4.1"><a href="#section-3.3.4" class="auto internal xref">3.3.4</a>.  <a href="#name-tokens" class="internal xref">Tokens</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.5">
                    <p id="section-toc.1-1.3.2.3.2.5.1"><a href="#section-3.3.5" class="auto internal xref">3.3.5</a>.  <a href="#name-byte-sequences" class="internal xref">Byte Sequences</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.6">
                    <p id="section-toc.1-1.3.2.3.2.6.1"><a href="#section-3.3.6" class="auto internal xref">3.3.6</a>.  <a href="#name-booleans" class="internal xref">Booleans</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.7">
                    <p id="section-toc.1-1.3.2.3.2.7.1"><a href="#section-3.3.7" class="auto internal xref">3.3.7</a>.  <a href="#name-dates" class="internal xref">Dates</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3.2.8">
                    <p id="section-toc.1-1.3.2.3.2.8.1"><a href="#section-3.3.8" class="auto internal xref">3.3.8</a>.  <a href="#name-display-strings" class="internal xref">Display Strings</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-working-with-structured-fie" class="internal xref">Working with Structured Fields in HTTP</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-serializing-structured-fiel" class="internal xref">Serializing Structured Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.1">
                    <p id="section-toc.1-1.4.2.1.2.1.1"><a href="#section-4.1.1" class="auto internal xref">4.1.1</a>.  <a href="#name-serializing-a-list" class="internal xref">Serializing a List</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.2">
                    <p id="section-toc.1-1.4.2.1.2.2.1"><a href="#section-4.1.2" class="auto internal xref">4.1.2</a>.  <a href="#name-serializing-a-dictionary" class="internal xref">Serializing a Dictionary</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.3">
                    <p id="section-toc.1-1.4.2.1.2.3.1"><a href="#section-4.1.3" class="auto internal xref">4.1.3</a>.  <a href="#name-serializing-an-item" class="internal xref">Serializing an Item</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.4">
                    <p id="section-toc.1-1.4.2.1.2.4.1"><a href="#section-4.1.4" class="auto internal xref">4.1.4</a>.  <a href="#name-serializing-an-integer" class="internal xref">Serializing an Integer</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.5">
                    <p id="section-toc.1-1.4.2.1.2.5.1"><a href="#section-4.1.5" class="auto internal xref">4.1.5</a>.  <a href="#name-serializing-a-decimal" class="internal xref">Serializing a Decimal</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.6">
                    <p id="section-toc.1-1.4.2.1.2.6.1"><a href="#section-4.1.6" class="auto internal xref">4.1.6</a>.  <a href="#name-serializing-a-string" class="internal xref">Serializing a String</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.7">
                    <p id="section-toc.1-1.4.2.1.2.7.1"><a href="#section-4.1.7" class="auto internal xref">4.1.7</a>.  <a href="#name-serializing-a-token" class="internal xref">Serializing a Token</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.8">
                    <p id="section-toc.1-1.4.2.1.2.8.1"><a href="#section-4.1.8" class="auto internal xref">4.1.8</a>.  <a href="#name-serializing-a-byte-sequence" class="internal xref">Serializing a Byte Sequence</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.9">
                    <p id="section-toc.1-1.4.2.1.2.9.1"><a href="#section-4.1.9" class="auto internal xref">4.1.9</a>.  <a href="#name-serializing-a-boolean" class="internal xref">Serializing a Boolean</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.10">
                    <p id="section-toc.1-1.4.2.1.2.10.1"><a href="#section-4.1.10" class="auto internal xref">4.1.10</a>. <a href="#name-serializing-a-date" class="internal xref">Serializing a Date</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1.2.11">
                    <p id="section-toc.1-1.4.2.1.2.11.1"><a href="#section-4.1.11" class="auto internal xref">4.1.11</a>. <a href="#name-serializing-a-display-strin" class="internal xref">Serializing a Display String</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-parsing-structured-fields" class="internal xref">Parsing Structured Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-parsing-a-list" class="internal xref">Parsing a List</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="auto internal xref">4.2.2</a>.  <a href="#name-parsing-a-dictionary" class="internal xref">Parsing a Dictionary</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="auto internal xref">4.2.3</a>.  <a href="#name-parsing-an-item" class="internal xref">Parsing an Item</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.4">
                    <p id="section-toc.1-1.4.2.2.2.4.1"><a href="#section-4.2.4" class="auto internal xref">4.2.4</a>.  <a href="#name-parsing-an-integer-or-decim" class="internal xref">Parsing an Integer or Decimal</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.5">
                    <p id="section-toc.1-1.4.2.2.2.5.1"><a href="#section-4.2.5" class="auto internal xref">4.2.5</a>.  <a href="#name-parsing-a-string" class="internal xref">Parsing a String</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.6">
                    <p id="section-toc.1-1.4.2.2.2.6.1"><a href="#section-4.2.6" class="auto internal xref">4.2.6</a>.  <a href="#name-parsing-a-token" class="internal xref">Parsing a Token</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.7">
                    <p id="section-toc.1-1.4.2.2.2.7.1"><a href="#section-4.2.7" class="auto internal xref">4.2.7</a>.  <a href="#name-parsing-a-byte-sequence" class="internal xref">Parsing a Byte Sequence</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.8">
                    <p id="section-toc.1-1.4.2.2.2.8.1"><a href="#section-4.2.8" class="auto internal xref">4.2.8</a>.  <a href="#name-parsing-a-boolean" class="internal xref">Parsing a Boolean</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.9">
                    <p id="section-toc.1-1.4.2.2.2.9.1"><a href="#section-4.2.9" class="auto internal xref">4.2.9</a>.  <a href="#name-parsing-a-date" class="internal xref">Parsing a Date</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.10">
                    <p id="section-toc.1-1.4.2.2.2.10.1"><a href="#section-4.2.10" class="auto internal xref">4.2.10</a>. <a href="#name-parsing-a-display-string" class="internal xref">Parsing a Display String</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-frequently-asked-questions" class="internal xref">Frequently Asked Questions</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#appendix-A.1" class="auto internal xref">A.1</a>.  <a href="#name-why-not-json" class="internal xref">Why Not JSON?</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-implementation-notes" class="internal xref">Implementation Notes</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#appendix-C" class="auto internal xref">Appendix C</a>.  <a href="#name-abnf" class="internal xref">ABNF</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-D" class="auto internal xref">Appendix D</a>.  <a href="#name-changes-from-rfc-8941" class="internal xref">Changes from RFC 8941</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-E" class="auto internal xref"></a><a href="#name-acknowledgements" class="internal xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-F" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Specifying the syntax of new HTTP header (and trailer) fields is an onerous task; even with the guidance in <span><a href="https://rfc-editor.org/rfc/rfc9110#section-16.3.2" class="relref">Section 16.3.2</a> of [<a href="#HTTP" class="cite xref">HTTP</a>]</span>, there are many decisions -- and pitfalls -- for a prospective HTTP field author.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">Once a field is defined, bespoke parsers and serializers often need to be written, because each field value has a slightly different handling of what looks like common syntax.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">This document introduces a set of common data structures for use in definitions of new HTTP field values to address these problems. In particular, it defines a generic, abstract model for them, along with a concrete serialization for expressing that model in HTTP <span>[<a href="#HTTP" class="cite xref">HTTP</a>]</span> header and trailer fields.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">An HTTP field that is defined as a "Structured Header" or "Structured Trailer" (if the field can be either, it is a "Structured Field") uses the types defined in this specification to define its syntax and basic handling rules, thereby simplifying both its definition by specification writers and handling by implementations.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">Additionally, future versions of HTTP can define alternative serializations of the abstract model of these structures, allowing fields that use that model to be transmitted more efficiently without being redefined.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">Note that it is not a goal of this document to redefine the syntax of existing HTTP fields; the mechanisms described herein are only intended to be used with fields that explicitly opt into them.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7"><a href="#specify" class="auto internal xref">Section 2</a> describes how to specify a Structured Field.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8"><a href="#types" class="auto internal xref">Section 3</a> defines a number of abstract data types that can be used in Structured Fields.<a href="#section-1-8" class="pilcrow">¶</a></p>
<p id="section-1-9">Those abstract types can be serialized into and parsed from HTTP field values using the algorithms described in <a href="#text" class="auto internal xref">Section 4</a>.<a href="#section-1-9" class="pilcrow">¶</a></p>
<div id="strict">
<section id="section-1.1">
        <h3 id="name-intentionally-strict-proces">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-intentionally-strict-proces" class="section-name selfRef">Intentionally Strict Processing</a>
        </h3>
<p id="section-1.1-1">This specification intentionally defines strict parsing and serialization behaviors using step-by-step algorithms; the only error handling defined is to fail the entire operation altogether.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">It is designed to encourage faithful implementation and good interoperability. Therefore, an implementation that tried to be helpful by being more tolerant of input would make interoperability worse, since that would create pressure on other implementations to implement similar (but likely subtly different) workarounds.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">In other words, strict processing is an intentional feature of this specification; it allows non-conformant input to be discovered and corrected by the producer early and avoids both interoperability and security issues that might otherwise result.<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<p id="section-1.1-4">Note that as a result of this strictness, if a field is appended to by multiple parties (e.g., intermediaries or different components in the sender), an error in one party's value is likely to cause the entire field value to fail parsing.<a href="#section-1.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="notational-conventions">
<section id="section-1.2">
        <h3 id="name-notational-conventions">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-notational-conventions" class="section-name selfRef">Notational Conventions</a>
        </h3>
<p id="section-1.2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they appear in all capitals, as shown here.<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<p id="section-1.2-2">This document uses the VCHAR, SP, DIGIT, ALPHA, and DQUOTE rules from <span>[<a href="#RFC5234" class="cite xref">RFC5234</a>]</span> to specify characters and/or their corresponding ASCII bytes, depending on context. It uses the tchar and OWS rules from <span>[<a href="#HTTP" class="cite xref">HTTP</a>]</span> for the same purpose.<a href="#section-1.2-2" class="pilcrow">¶</a></p>
<p id="section-1.2-3">This document uses algorithms to specify parsing and serialization behaviors. When parsing from HTTP fields, implementations MUST have behavior that is indistinguishable from following the algorithms.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<p id="section-1.2-4">For serialization to HTTP fields, the algorithms define the recommended way to produce them. Implementations MAY vary from the specified behavior so long as the output is still correctly handled by the parsing algorithm described in <a href="#text-parse" class="auto internal xref">Section 4.2</a>.<a href="#section-1.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="specify">
<section id="section-2">
      <h2 id="name-defining-new-structured-fie">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-defining-new-structured-fie" class="section-name selfRef">Defining New Structured Fields</a>
      </h2>
<p id="section-2-1">To specify an HTTP field as a Structured Field, its authors need to:<a href="#section-2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-2.1">
          <p id="section-2-2.1.1">Normatively reference this specification. Recipients and generators of the field need to know that the requirements of this document are in effect.<a href="#section-2-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.2">
          <p id="section-2-2.2.1">Identify whether the field is a Structured Header (i.e., it can only be used in the header section -- the common case), a Structured Trailer (only in the trailer section), or a Structured Field (both).<a href="#section-2-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.3">
          <p id="section-2-2.3.1">Specify the type of the field value; either List (<a href="#list" class="auto internal xref">Section 3.1</a>), Dictionary (<a href="#dictionary" class="auto internal xref">Section 3.2</a>), or Item (<a href="#item" class="auto internal xref">Section 3.3</a>).<a href="#section-2-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.4">
          <p id="section-2-2.4.1">Define the semantics of the field value.<a href="#section-2-2.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-2.5">
          <p id="section-2-2.5.1">Specify any additional constraints upon the field value, as well as the consequences when those constraints are violated.<a href="#section-2-2.5.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-3">Typically, this means that a field definition will specify the top-level type -- List, Dictionary, or Item -- and then define its allowable types and constraints upon them. For example, a header defined as a List might have all Integer members, or a mix of types; a header defined as an Item might allow only Strings, and additionally only strings beginning with the letter "Q", or strings in lowercase. Likewise, Inner Lists (<a href="#inner-list" class="auto internal xref">Section 3.1.1</a>) are only valid when a field definition explicitly allows them.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Fields that use the Display String type are advised to carefully specify their allowable unicode code points; for example, specifying the use of a profile from <span>[<a href="#PRECIS" class="cite xref">PRECIS</a>]</span>.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">Field definitions can only use this specification for the entire field value, not a portion thereof.<a href="#section-2-5" class="pilcrow">¶</a></p>
<p id="section-2-6">Specifications can refer to a field name as a "structured header name", "structured trailer name", or "structured field name" as appropriate. Likewise, they can refer its field value as a "structured header value", "structured trailer value", or "structured field value" as necessary.<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">This specification defines minimums for the length or number of various structures supported by implementations. It does not specify maximum sizes in most cases, but authors should be aware that HTTP implementations do impose various limits on the size of individual fields, the total number of fields, and/or the size of the entire header or trailer section.<a href="#section-2-7" class="pilcrow">¶</a></p>
<div id="example">
<section id="section-2.1">
        <h3 id="name-example">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-example" class="section-name selfRef">Example</a>
        </h3>
<p id="section-2.1-1">A fictitious Foo-Example header field might be specified as:<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<blockquote id="section-2.1-2">
          <p id="section-2.1-2.1">42. Foo-Example Header Field<a href="#section-2.1-2.1" class="pilcrow">¶</a></p>
<p id="section-2.1-2.2">The Foo-Example HTTP header field conveys information about how
much Foo the message has.<a href="#section-2.1-2.2" class="pilcrow">¶</a></p>
<p id="section-2.1-2.3">Foo-Example is an Item Structured Header Field [RFCnnnn]. Its value
MUST be an Integer (Section 3.3.1 of [RFCnnnn]).<a href="#section-2.1-2.3" class="pilcrow">¶</a></p>
<p id="section-2.1-2.4">Its value indicates the amount of Foo in the message, and it MUST
be between 0 and 10, inclusive; other values MUST cause
the entire header field to be ignored.<a href="#section-2.1-2.4" class="pilcrow">¶</a></p>
<p id="section-2.1-2.5">The following parameter is defined:<a href="#section-2.1-2.5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.1-2.6.1">A parameter whose key is "foourl", and whose value is a String
  (Section 3.3.3 of [RFCnnnn]), conveying the Foo URL
  for the message. See below for processing requirements.<a href="#section-2.1-2.6.1" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-2.1-2.7">"foourl" contains a URI-reference (Section 4.1 of [RFC3986]). If
its value is not a valid URI-reference, the entire header field
MUST be ignored. If its value is a relative reference (Section 4.2
of [RFC3986]), it MUST be resolved (Section 5 of [RFC3986]) before
being used.<a href="#section-2.1-2.7" class="pilcrow">¶</a></p>
<p id="section-2.1-2.8">For example:<a href="#section-2.1-2.8" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.1-2.9">
<pre>
  Foo-Example: 2; foourl="https://foo.example.com/"
</pre><a href="#section-2.1-2.9" class="pilcrow">¶</a>
</div>
</blockquote>
</section>
</div>
<div id="error-handling">
<section id="section-2.2">
        <h3 id="name-error-handling">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-error-handling" class="section-name selfRef">Error Handling</a>
        </h3>
<p id="section-2.2-1">When parsing fails, the entire field is ignored (see <a href="#text-parse" class="auto internal xref">Section 4.2</a>). Field definitions cannot override this, because doing so would preclude handling by generic software; they can only add additional constraints (for example, on the numeric range of Integers and Decimals, the format of Strings and Tokens, the types allowed in a Dictionary's values, or the number of Items in a List).<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<p id="section-2.2-2">When field-specific constraints are violated, the entire field is also ignored, unless the field definition defines other handling requirements. For example, if a header field is defined as an Item and required to be an Integer, but a String is received, it should be ignored unless that field's definition explicitly specifies otherwise.<a href="#section-2.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="preserving-extensibility">
<section id="section-2.3">
        <h3 id="name-preserving-extensibility">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-preserving-extensibility" class="section-name selfRef">Preserving Extensibility</a>
        </h3>
<p id="section-2.3-1">Structured Fields are designed to be extensible, because experience has shown that even when it is not foreseen, it is often necessary to modify and add to the allowable syntax and semantics of a field in a controlled fashion.<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<p id="section-2.3-2">Both Items and Inner Lists allow Parameters as an extensibility mechanism; this means that their values can later be extended to accommodate more information, if need be. To preserve forward compatibility, field specifications are discouraged from defining the presence of an unrecognized parameter as an error condition.<a href="#section-2.3-2" class="pilcrow">¶</a></p>
<p id="section-2.3-3">Field specifications are required to be either an Item, List, or Dictionary to preserve extensibility. Fields that erroneously defined as another type (e.g., Integer) are assumed to be Items (i.e., they allow Parameters).<a href="#section-2.3-3" class="pilcrow">¶</a></p>
<p id="section-2.3-4">To further assure that this extensibility is available in the future, and to encourage consumers to use a complete parser implementation, a field definition can specify that "grease" parameters be added by senders. A specification could stipulate that all parameters that fit a defined pattern are reserved for this use and then encourage them to be sent on some portion of requests. This helps to discourage recipients from writing a parser that does not account for Parameters.<a href="#section-2.3-4" class="pilcrow">¶</a></p>
<p id="section-2.3-5">Specifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of -- as well as value and type associated with -- unknown keys be ignored. Subsequent specifications can then add additional keys, specifying constraints on them as appropriate.<a href="#section-2.3-5" class="pilcrow">¶</a></p>
<p id="section-2.3-6">An extension to a Structured Field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.<a href="#section-2.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="using-new-structured-types-in-extensions">
<section id="section-2.4">
        <h3 id="name-using-new-structured-types-">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-using-new-structured-types-" class="section-name selfRef">Using New Structured Types in Extensions</a>
        </h3>
<p id="section-2.4-1">Because a field definition needs to reference a specific RFC for Structured Fields, the types available for use in its value are limited to those defined in that RFC. For example, a field whose definition references this document can have a value that uses the Date type (<a href="#date" class="auto internal xref">Section 3.3.7</a>), whereas a field whose definition references RFC 8941 cannot, because it will be treated as invalid (and therefore discarded) by implementations of that specification.<a href="#section-2.4-1" class="pilcrow">¶</a></p>
<p id="section-2.4-2">This limitation also applies to future extensions to a field; for example, a field that is defined with reference to RFC 8941 cannot use the Date type, because some recipients might still be using an RFC 8941 parser to process it.<a href="#section-2.4-2" class="pilcrow">¶</a></p>
<p id="section-2.4-3">However, this document is designed to be backwards-compatible with RFC 8941; a parser that implements the requirements here can also parse valid Structured Fields whose definitions reference RFC 8941.<a href="#section-2.4-3" class="pilcrow">¶</a></p>
<p id="section-2.4-4">Upgrading a Structured Fields implementation to support a newer revision of the specification (such as this document) brings the possibility that some field values that were invalid according to the earlier RFC might become valid when processed.<a href="#section-2.4-4" class="pilcrow">¶</a></p>
<p id="section-2.4-5">For example, field instance might contain a syntactically valid Date (<a href="#date" class="auto internal xref">Section 3.3.7</a>), even though that field's definition does not accommodate Dates. An RFC8941 implementation would fail parsing such a field instance, because they are not defined in that specification. If that implementation were upgraded to this specification, parsing would now succeed. In some cases, the resulting Date value will be rejected by field-specific logic, but values in fields that are otherwise ignored (such as extension parameters) might not be detected and the field might subsequently be accepted and processed.<a href="#section-2.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="types">
<section id="section-3">
      <h2 id="name-structured-data-types">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-structured-data-types" class="section-name selfRef">Structured Data Types</a>
      </h2>
<p id="section-3-1">This section provides an overview of the abstract types that Structured Fields use, and gives a brief description and examples of how each of those types are serialized into textual HTTP fields. <a href="#text" class="auto internal xref">Section 4</a> specifies the details of how they are parsed from and serialized into textual HTTP fields.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">In summary:<a href="#section-3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.1">
          <p id="section-3-3.1.1">There are three top-level types that an HTTP field can be defined as: Lists, Dictionaries, and Items.<a href="#section-3-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.2">
          <p id="section-3-3.2.1">Lists and Dictionaries are containers; their members can be Items or Inner Lists (which are themselves arrays of Items).<a href="#section-3-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.3">
          <p id="section-3-3.3.1">Both Items and Inner Lists can be Parameterized with key/value pairs.<a href="#section-3-3.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<div id="list">
<section id="section-3.1">
        <h3 id="name-lists">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-lists" class="section-name selfRef">Lists</a>
        </h3>
<p id="section-3.1-1">Lists are arrays of zero or more members, each of which can be an Item (<a href="#item" class="auto internal xref">Section 3.3</a>) or an Inner List (<a href="#inner-list" class="auto internal xref">Section 3.1.1</a>), both of which can be Parameterized (<a href="#param" class="auto internal xref">Section 3.1.2</a>).<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">An empty List is denoted by not serializing the field at all. This implies that fields defined as Lists have a default empty value.<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<p id="section-3.1-3">When serialized as a textual HTTP field, each member is separated by a comma and optional whitespace. For example, a field whose value is defined as a List of Tokens could look like:<a href="#section-3.1-3" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1-4">
<pre>
Example-List: sugar, tea, rum
</pre><a href="#section-3.1-4" class="pilcrow">¶</a>
</div>
<p id="section-3.1-5">Note that Lists can have their members split across multiple lines of the same header or trailer section, as per <span><a href="https://rfc-editor.org/rfc/rfc9110#section-5.3" class="relref">Section 5.3</a> of [<a href="#HTTP" class="cite xref">HTTP</a>]</span>; for example, the following are equivalent:<a href="#section-3.1-5" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1-6">
<pre>
Example-List: sugar, tea, rum
</pre><a href="#section-3.1-6" class="pilcrow">¶</a>
</div>
<p id="section-3.1-7">and<a href="#section-3.1-7" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1-8">
<pre>
Example-List: sugar, tea
Example-List: rum
</pre><a href="#section-3.1-8" class="pilcrow">¶</a>
</div>
<p id="section-3.1-9">However, individual members of a List cannot be safely split between lines; see <a href="#text-parse" class="auto internal xref">Section 4.2</a> for details.<a href="#section-3.1-9" class="pilcrow">¶</a></p>
<p id="section-3.1-10">Parsers MUST support Lists containing at least 1024 members. Field specifications can constrain the types and cardinality of individual List values as they require.<a href="#section-3.1-10" class="pilcrow">¶</a></p>
<div id="inner-list">
<section id="section-3.1.1">
          <h4 id="name-inner-lists">
<a href="#section-3.1.1" class="section-number selfRef">3.1.1. </a><a href="#name-inner-lists" class="section-name selfRef">Inner Lists</a>
          </h4>
<p id="section-3.1.1-1">An Inner List is an array of zero or more Items (<a href="#item" class="auto internal xref">Section 3.3</a>). Both the individual Items and the Inner List itself can be Parameterized (<a href="#param" class="auto internal xref">Section 3.1.2</a>).<a href="#section-3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1.1-2">When serialized in a textual HTTP field, Inner Lists are denoted by surrounding parenthesis, and their values are delimited by one or more spaces. A field whose value is defined as a List of Inner Lists of Strings could look like:<a href="#section-3.1.1-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1.1-3">
<pre>
Example-List: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</pre><a href="#section-3.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.1-4">Note that the last member in this example is an empty Inner List.<a href="#section-3.1.1-4" class="pilcrow">¶</a></p>
<p id="section-3.1.1-5">A header field whose value is defined as a List of Inner Lists with Parameters at both levels could look like:<a href="#section-3.1.1-5" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1.1-6">
<pre>
Example-List: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</pre><a href="#section-3.1.1-6" class="pilcrow">¶</a>
</div>
<p id="section-3.1.1-7">Parsers MUST support Inner Lists containing at least 256 members. Field specifications can constrain the types and cardinality of individual Inner List members as they require.<a href="#section-3.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="param">
<section id="section-3.1.2">
          <h4 id="name-parameters">
<a href="#section-3.1.2" class="section-number selfRef">3.1.2. </a><a href="#name-parameters" class="section-name selfRef">Parameters</a>
          </h4>
<p id="section-3.1.2-1">Parameters are an ordered map of key-value pairs that are associated with an Item (<a href="#item" class="auto internal xref">Section 3.3</a>) or Inner List (<a href="#inner-list" class="auto internal xref">Section 3.1.1</a>). The keys are unique within the scope of the Parameters they occur within, and the values are bare items (i.e., they themselves cannot be parameterized; see <a href="#item" class="auto internal xref">Section 3.3</a>).<a href="#section-3.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.1.2-2">Implementations MUST provide access to Parameters both by index and by key. Specifications MAY use either means of accessing them.<a href="#section-3.1.2-2" class="pilcrow">¶</a></p>
<p id="section-3.1.2-3">Note that parameters are ordered, and parameter keys cannot contain uppercase letters.<a href="#section-3.1.2-3" class="pilcrow">¶</a></p>
<p id="section-3.1.2-4">When serialized in a textual HTTP field, a Parameter is separated from its Item or Inner List and other Parameters by a semicolon. For example:<a href="#section-3.1.2-4" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1.2-5">
<pre>
Example-List: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</pre><a href="#section-3.1.2-5" class="pilcrow">¶</a>
</div>
<p id="section-3.1.2-6">Parameters whose value is Boolean (see <a href="#boolean" class="auto internal xref">Section 3.3.6</a>) true MUST omit that value when serialized. For example, the "a" parameter here is true, while the "b" parameter is false:<a href="#section-3.1.2-6" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.1.2-7">
<pre>
Example-Integer: 1; a; b=?0
</pre><a href="#section-3.1.2-7" class="pilcrow">¶</a>
</div>
<p id="section-3.1.2-8">Note that this requirement is only on serialization; parsers are still required to correctly handle the true value when it appears in a parameter.<a href="#section-3.1.2-8" class="pilcrow">¶</a></p>
<p id="section-3.1.2-9">Parsers MUST support at least 256 parameters on an Item or Inner List, and support parameter keys with at least 64 characters. Field specifications can constrain the order of individual parameters, as well as their values' types as required.<a href="#section-3.1.2-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="dictionary">
<section id="section-3.2">
        <h3 id="name-dictionaries">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-dictionaries" class="section-name selfRef">Dictionaries</a>
        </h3>
<p id="section-3.2-1">Dictionaries are ordered maps of key-value pairs, where the keys are short textual strings and the values are Items (<a href="#item" class="auto internal xref">Section 3.3</a>) or arrays of Items, both of which can be Parameterized (<a href="#param" class="auto internal xref">Section 3.1.2</a>). There can be zero or more members, and their keys are unique in the scope of the Dictionary they occur within.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">Implementations MUST provide access to Dictionaries both by index and by key. Specifications MAY use either means of accessing the members.<a href="#section-3.2-2" class="pilcrow">¶</a></p>
<p id="section-3.2-3">As with Lists, an empty Dictionary is represented by omitting the entire field. This implies that fields defined as Dictionaries have a default empty value.<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">Typically, a field specification will define the semantics of Dictionaries by specifying the allowed type(s) for individual members by their keys, as well as whether their presence is required or optional. Recipients MUST ignore members whose keys are undefined or unknown, unless the field's specification specifically disallows them.<a href="#section-3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.2-5">When serialized as a textual HTTP field, Members are ordered as serialized and separated by a comma with optional whitespace. Member keys cannot contain uppercase characters. Keys and values are separated by "=" (without whitespace). For example:<a href="#section-3.2-5" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-6">
<pre>
Example-Dict: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</pre><a href="#section-3.2-6" class="pilcrow">¶</a>
</div>
<p id="section-3.2-7">Note that in this example, the final "=" is due to the inclusion of a Byte Sequence; see <a href="#binary" class="auto internal xref">Section 3.3.5</a>.<a href="#section-3.2-7" class="pilcrow">¶</a></p>
<p id="section-3.2-8">Members whose value is Boolean (see <a href="#boolean" class="auto internal xref">Section 3.3.6</a>) true MUST omit that value when serialized. For example, here both "b" and "c" are true:<a href="#section-3.2-8" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-9">
<pre>
Example-Dict: a=?0, b, c; foo=bar
</pre><a href="#section-3.2-9" class="pilcrow">¶</a>
</div>
<p id="section-3.2-10">Note that this requirement is only on serialization; parsers are still required to correctly handle the true Boolean value when it appears in Dictionary values.<a href="#section-3.2-10" class="pilcrow">¶</a></p>
<p id="section-3.2-11">A Dictionary with a member whose value is an Inner List of Tokens:<a href="#section-3.2-11" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-12">
<pre>
Example-Dict: rating=1.5, feelings=(joy sadness)
</pre><a href="#section-3.2-12" class="pilcrow">¶</a>
</div>
<p id="section-3.2-13">A Dictionary with a mix of Items and Inner Lists, some with parameters:<a href="#section-3.2-13" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-14">
<pre>
Example-Dict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid
</pre><a href="#section-3.2-14" class="pilcrow">¶</a>
</div>
<p id="section-3.2-15">Note that Dictionaries can have their members split across multiple lines of the same header or trailer section; for example, the following are equivalent:<a href="#section-3.2-15" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-16">
<pre>
Example-Dict: foo=1, bar=2
</pre><a href="#section-3.2-16" class="pilcrow">¶</a>
</div>
<p id="section-3.2-17">and<a href="#section-3.2-17" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.2-18">
<pre>
Example-Dict: foo=1
Example-Dict: bar=2
</pre><a href="#section-3.2-18" class="pilcrow">¶</a>
</div>
<p id="section-3.2-19">However, individual members of a Dictionary cannot be safely split between lines; see <a href="#text-parse" class="auto internal xref">Section 4.2</a> for details.<a href="#section-3.2-19" class="pilcrow">¶</a></p>
<p id="section-3.2-20">Parsers MUST support Dictionaries containing at least 1024 key/value pairs and keys with at least 64 characters. Field specifications can constrain the order of individual Dictionary members, as well as their values' types as required.<a href="#section-3.2-20" class="pilcrow">¶</a></p>
</section>
</div>
<div id="item">
<section id="section-3.3">
        <h3 id="name-items">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-items" class="section-name selfRef">Items</a>
        </h3>
<p id="section-3.3-1">An Item can be an Integer (<a href="#integer" class="auto internal xref">Section 3.3.1</a>), a Decimal (<a href="#decimal" class="auto internal xref">Section 3.3.2</a>), a String (<a href="#string" class="auto internal xref">Section 3.3.3</a>), a Token (<a href="#token" class="auto internal xref">Section 3.3.4</a>), a Byte Sequence (<a href="#binary" class="auto internal xref">Section 3.3.5</a>), a Boolean (<a href="#boolean" class="auto internal xref">Section 3.3.6</a>), or a Date (<a href="#date" class="auto internal xref">Section 3.3.7</a>). It can have associated parameters (<a href="#param" class="auto internal xref">Section 3.1.2</a>).<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">For example, a header field that is defined to be an Item that is an Integer might look like:<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3-3">
<pre>
Example-Integer: 5
</pre><a href="#section-3.3-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3-4">or with parameters:<a href="#section-3.3-4" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3-5">
<pre>
Example-Integer: 5; foo=bar
</pre><a href="#section-3.3-5" class="pilcrow">¶</a>
</div>
<div id="integer">
<section id="section-3.3.1">
          <h4 id="name-integers">
<a href="#section-3.3.1" class="section-number selfRef">3.3.1. </a><a href="#name-integers" class="section-name selfRef">Integers</a>
          </h4>
<p id="section-3.3.1-1">Integers have a range of -999,999,999,999,999 to 999,999,999,999,999 inclusive (i.e., up to fifteen digits, signed), for IEEE 754 compatibility <span>[<a href="#IEEE754" class="cite xref">IEEE754</a>]</span>.<a href="#section-3.3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.3.1-2">For example:<a href="#section-3.3.1-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.1-3">
<pre>
Example-Integer: 42
</pre><a href="#section-3.3.1-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3.1-4">Integers larger than 15 digits can be supported in a variety of ways; for example, by using a String (<a href="#string" class="auto internal xref">Section 3.3.3</a>), a Byte Sequence (<a href="#binary" class="auto internal xref">Section 3.3.5</a>), or a parameter on an Integer that acts as a scaling factor.<a href="#section-3.3.1-4" class="pilcrow">¶</a></p>
<p id="section-3.3.1-5">While it is possible to serialize Integers with leading zeros (e.g., "0002", "-01") and signed zero ("-0"), these distinctions may not be preserved by implementations.<a href="#section-3.3.1-5" class="pilcrow">¶</a></p>
<p id="section-3.3.1-6">Note that commas in Integers are used in this section's prose only for readability; they are not valid in the wire format.<a href="#section-3.3.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="decimal">
<section id="section-3.3.2">
          <h4 id="name-decimals">
<a href="#section-3.3.2" class="section-number selfRef">3.3.2. </a><a href="#name-decimals" class="section-name selfRef">Decimals</a>
          </h4>
<p id="section-3.3.2-1">Decimals are numbers with an integer and a fractional component. The integer component has at most 12 digits; the fractional component has at most three digits.<a href="#section-3.3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.3.2-2">For example, a header whose value is defined as a Decimal could look like:<a href="#section-3.3.2-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.2-3">
<pre>
Example-Decimal: 4.5
</pre><a href="#section-3.3.2-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3.2-4">While it is possible to serialize Decimals with leading zeros (e.g., "0002.5", "-01.334"), trailing zeros (e.g., "5.230", "-0.40"), and signed zero (e.g., "-0.0"), these distinctions may not be preserved by implementations.<a href="#section-3.3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.3.2-5">Note that the serialization algorithm (<a href="#ser-decimal" class="auto internal xref">Section 4.1.5</a>) rounds input with more than three digits of precision in the fractional component. If an alternative rounding strategy is desired, this should be specified by the field definition to occur before serialization.<a href="#section-3.3.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="string">
<section id="section-3.3.3">
          <h4 id="name-strings">
<a href="#section-3.3.3" class="section-number selfRef">3.3.3. </a><a href="#name-strings" class="section-name selfRef">Strings</a>
          </h4>
<p id="section-3.3.3-1">Strings are zero or more printable ASCII <span>[<a href="#RFC0020" class="cite xref">RFC0020</a>]</span> characters (i.e., the range %x20 to %x7E). Note that this excludes tabs, newlines, carriage returns, etc.<a href="#section-3.3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3.3-2">Non-ASCII characters are not directly supported in Strings, because they cause a number of interoperability issues, and -- with few exceptions -- field values do not require them.<a href="#section-3.3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3.3-3">When it is necessary for a field value to convey non-ASCII content, a Display String (<a href="#displaystring" class="auto internal xref">Section 3.3.8</a>) can be specified.<a href="#section-3.3.3-3" class="pilcrow">¶</a></p>
<p id="section-3.3.3-4">When serialized in a textual HTTP field, Strings are delimited with double quotes, using a backslash ("\") to escape double quotes and backslashes. For example:<a href="#section-3.3.3-4" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.3-5">
<pre>
Example-String: "hello world"
</pre><a href="#section-3.3.3-5" class="pilcrow">¶</a>
</div>
<p id="section-3.3.3-6">Note that Strings only use DQUOTE as a delimiter; single quotes do not delimit Strings. Furthermore, only DQUOTE and "\" can be escaped; other characters after "\" MUST cause parsing to fail.<a href="#section-3.3.3-6" class="pilcrow">¶</a></p>
<p id="section-3.3.3-7">Parsers MUST support Strings (after any decoding) with at least 1024 characters.<a href="#section-3.3.3-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="token">
<section id="section-3.3.4">
          <h4 id="name-tokens">
<a href="#section-3.3.4" class="section-number selfRef">3.3.4. </a><a href="#name-tokens" class="section-name selfRef">Tokens</a>
          </h4>
<p id="section-3.3.4-1">Tokens are short textual words that begin with an alphabetic character or "*", followed by zero to many token characters, which are the same as those allowed by the "token" ABNF rule defined in <span>[<a href="#HTTP" class="cite xref">HTTP</a>]</span>, plus the ":" and "/" characters.<a href="#section-3.3.4-1" class="pilcrow">¶</a></p>
<p id="section-3.3.4-2">For example:<a href="#section-3.3.4-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.4-3">
<pre>
Example-Token: foo123/456
</pre><a href="#section-3.3.4-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3.4-4">Parsers MUST support Tokens with at least 512 characters.<a href="#section-3.3.4-4" class="pilcrow">¶</a></p>
<p id="section-3.3.4-5">Note that Tokens are defined largely for compatibility with the data model of existing HTTP fields, and may require additional steps to use in some implementations. As a result, new fields are encouraged to use Strings.<a href="#section-3.3.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="binary">
<section id="section-3.3.5">
          <h4 id="name-byte-sequences">
<a href="#section-3.3.5" class="section-number selfRef">3.3.5. </a><a href="#name-byte-sequences" class="section-name selfRef">Byte Sequences</a>
          </h4>
<p id="section-3.3.5-1">Byte Sequences can be conveyed in Structured Fields.<a href="#section-3.3.5-1" class="pilcrow">¶</a></p>
<p id="section-3.3.5-2">When serialized in a textual HTTP field, a Byte Sequence is delimited with colons and encoded using base64 (<span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4" class="relref">Section 4</a></span>). For example:<a href="#section-3.3.5-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.5-3">
<pre>
Example-ByteSequence: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</pre><a href="#section-3.3.5-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3.5-4">Parsers MUST support Byte Sequences with at least 16384 octets after decoding.<a href="#section-3.3.5-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="boolean">
<section id="section-3.3.6">
          <h4 id="name-booleans">
<a href="#section-3.3.6" class="section-number selfRef">3.3.6. </a><a href="#name-booleans" class="section-name selfRef">Booleans</a>
          </h4>
<p id="section-3.3.6-1">Boolean values can be conveyed in Structured Fields.<a href="#section-3.3.6-1" class="pilcrow">¶</a></p>
<p id="section-3.3.6-2">When serialized in a textual HTTP field, a Boolean is indicated with a leading "?" character followed by a "1" for a true value or "0" for false. For example:<a href="#section-3.3.6-2" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-3.3.6-3">
<pre>
Example-Boolean: ?1
</pre><a href="#section-3.3.6-3" class="pilcrow">¶</a>
</div>
<p id="section-3.3.6-4">Note that in Dictionary (<a href="#dictionary" class="auto internal xref">Section 3.2</a>) and Parameter (<a href="#param" class="auto internal xref">Section 3.1.2</a>) values, Boolean true is indicated by omitting the value.<a href="#section-3.3.6-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="date">
<section id="section-3.3.7">
          <h4 id="name-dates">
<a href="#section-3.3.7" class="section-number selfRef">3.3.7. </a><a href="#name-dates" class="section-name selfRef">Dates</a>
          </h4>
<p id="section-3.3.7-1">Date values can be conveyed in Structured Fields.<a href="#section-3.3.7-1" class="pilcrow">¶</a></p>
<p id="section-3.3.7-2">Dates have a data model that is similar to Integers, representing a (possibly negative) delta in seconds from 1970-01-01T00:00:00Z, excluding leap seconds. Accordingly, their serialization in textual HTTP fields is similar to that of Integers, distinguished from them with a leading "@".<a href="#section-3.3.7-2" class="pilcrow">¶</a></p>
<p id="section-3.3.7-3">For example:<a href="#section-3.3.7-3" class="pilcrow">¶</a></p>
<div class="lang-http-message-new sourcecode" id="section-3.3.7-4">
<pre>
Example-Date: @1659578233
</pre><a href="#section-3.3.7-4" class="pilcrow">¶</a>
</div>
<p id="section-3.3.7-5">Parsers MUST support Dates whose values include all days in years 1 to 9999 (i.e., -62,135,596,800 to 253,402,214,400 delta seconds from 1970-01-01T00:00:00Z).<a href="#section-3.3.7-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="displaystring">
<section id="section-3.3.8">
          <h4 id="name-display-strings">
<a href="#section-3.3.8" class="section-number selfRef">3.3.8. </a><a href="#name-display-strings" class="section-name selfRef">Display Strings</a>
          </h4>
<p id="section-3.3.8-1">Display Strings are similar to Strings, in that they consist of zero or more characters, but they allow Unicode scalar values (i.e., all Unicode code points except for surrogates), unlike Strings.<a href="#section-3.3.8-1" class="pilcrow">¶</a></p>
<p id="section-3.3.8-2">Display Strings are intended for use in cases where a value is displayed to end users, and therefore may need to carry non-ASCII content. It is NOT RECOMMENDED that they be used in situations where a String (<a href="#string" class="auto internal xref">Section 3.3.3</a>) or Token (<a href="#token" class="auto internal xref">Section 3.3.4</a>) would be adequate, because Unicode has processing considerations (e.g., normalization) and security considerations (e.g., homograph attacks) that make it more difficult to handle correctly.<a href="#section-3.3.8-2" class="pilcrow">¶</a></p>
<p id="section-3.3.8-3">Note that Display Strings do not indicate the language used in the value; that can be done separately if necessary (e.g., with a parameter).<a href="#section-3.3.8-3" class="pilcrow">¶</a></p>
<p id="section-3.3.8-4">In textual HTTP fields, Display Strings are represented in a manner similar to Strings, except that non-ASCII characters are percent-encoded; there is a leading "%" to distinguish them from Strings.<a href="#section-3.3.8-4" class="pilcrow">¶</a></p>
<p id="section-3.3.8-5">For example:<a href="#section-3.3.8-5" class="pilcrow">¶</a></p>
<div class="lang-http-message-new sourcecode" id="section-3.3.8-6">
<pre>
Example-DisplayString: %"This is intended for display to %c3%bcsers."
</pre><a href="#section-3.3.8-6" class="pilcrow">¶</a>
</div>
<p id="section-3.3.8-7">See <a href="#security" class="auto internal xref">Section 6</a> for additional security considerations when handling Display Strings.<a href="#section-3.3.8-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="text">
<section id="section-4">
      <h2 id="name-working-with-structured-fie">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-working-with-structured-fie" class="section-name selfRef">Working with Structured Fields in HTTP</a>
      </h2>
<p id="section-4-1">This section defines how to serialize and parse the abstract types defined by <a href="#types" class="auto internal xref">Section 3</a> into textual HTTP field values and other encodings compatible with them (e.g., in HTTP/2 <span>[<a href="#RFC9113" class="cite xref">HTTP/2</a>]</span> before compression with HPACK <span>[<a href="#HPACK" class="cite xref">HPACK</a>]</span>).<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="text-serialize">
<section id="section-4.1">
        <h3 id="name-serializing-structured-fiel">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-serializing-structured-fiel" class="section-name selfRef">Serializing Structured Fields</a>
        </h3>
<p id="section-4.1-1">Given a structure defined in this specification, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1-2">
<li id="section-4.1-2.1">
            <p id="section-4.1-2.1.1">If the structure is a Dictionary or List and its value is empty (i.e., it has no members), do not serialize the field at all (i.e., omit both the field-name and field-value).<a href="#section-4.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-2.2">
            <p id="section-4.1-2.2.1">If the structure is a List, let output_string be the result of running Serializing a List (<a href="#ser-list" class="auto internal xref">Section 4.1.1</a>) with the structure.<a href="#section-4.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-2.3">
            <p id="section-4.1-2.3.1">Else, if the structure is a Dictionary, let output_string be the result of running Serializing a Dictionary (<a href="#ser-dictionary" class="auto internal xref">Section 4.1.2</a>) with the structure.<a href="#section-4.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-2.4">
            <p id="section-4.1-2.4.1">Else, if the structure is an Item, let output_string be the result of running Serializing an Item (<a href="#ser-item" class="auto internal xref">Section 4.1.3</a>) with the structure.<a href="#section-4.1-2.4.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-2.5">
            <p id="section-4.1-2.5.1">Else, fail serialization.<a href="#section-4.1-2.5.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.1-2.6">
            <p id="section-4.1-2.6.1">Return output_string converted into an array of bytes, using ASCII encoding <span>[<a href="#RFC0020" class="cite xref">RFC0020</a>]</span>.<a href="#section-4.1-2.6.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<div id="ser-list">
<section id="section-4.1.1">
          <h4 id="name-serializing-a-list">
<a href="#section-4.1.1" class="section-number selfRef">4.1.1. </a><a href="#name-serializing-a-list" class="section-name selfRef">Serializing a List</a>
          </h4>
<p id="section-4.1.1-1">Given an array of (member_value, parameters) tuples as input_list, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1-2">
<li id="section-4.1.1-2.1">
              <p id="section-4.1.1-2.1.1">Let output be an empty string.<a href="#section-4.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.1-2.2">
              <p id="section-4.1.1-2.2.1">For each (member_value, parameters) of input_list:<a href="#section-4.1.1-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1-2.2.2">
<li id="section-4.1.1-2.2.2.1">
                  <p id="section-4.1.1-2.2.2.1.1">If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist" class="auto internal xref">Section 4.1.1.1</a>) with (member_value, parameters) to output.<a href="#section-4.1.1-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.1.1-2.2.2.2">
                  <p id="section-4.1.1-2.2.2.2.1">Otherwise, append the result of running Serializing an Item (<a href="#ser-item" class="auto internal xref">Section 4.1.3</a>) with (member_value, parameters) to output.<a href="#section-4.1.1-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.1.1-2.2.2.3">
                  <p id="section-4.1.1-2.2.2.3.1">If more member_values remain in input_list:<a href="#section-4.1.1-2.2.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1-2.2.2.3.2">
<li id="section-4.1.1-2.2.2.3.2.1">
                      <p id="section-4.1.1-2.2.2.3.2.1.1">Append "," to output.<a href="#section-4.1.1-2.2.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.1-2.2.2.3.2.2">
                      <p id="section-4.1.1-2.2.2.3.2.2.1">Append a single SP to output.<a href="#section-4.1.1-2.2.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li id="section-4.1.1-2.3">
              <p id="section-4.1.1-2.3.1">Return output.<a href="#section-4.1.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<div id="ser-innerlist">
<section id="section-4.1.1.1">
            <h5 id="name-serializing-an-inner-list">
<a href="#section-4.1.1.1" class="section-number selfRef">4.1.1.1. </a><a href="#name-serializing-an-inner-list" class="section-name selfRef">Serializing an Inner List</a>
            </h5>
<p id="section-4.1.1.1-1">Given an array of (member_value, parameters) tuples as inner_list, and parameters as list_parameters, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.1.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.1-2">
<li id="section-4.1.1.1-2.1">
                <p id="section-4.1.1.1-2.1.1">Let output be the string "(".<a href="#section-4.1.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.1-2.2">
                <p id="section-4.1.1.1-2.2.1">For each (member_value, parameters) of inner_list:<a href="#section-4.1.1.1-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.1-2.2.2">
<li id="section-4.1.1.1-2.2.2.1">
                    <p id="section-4.1.1.1-2.2.2.1.1">Append the result of running Serializing an Item (<a href="#ser-item" class="auto internal xref">Section 4.1.3</a>) with (member_value, parameters) to output.<a href="#section-4.1.1.1-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.1.1.1-2.2.2.2">
                    <p id="section-4.1.1.1-2.2.2.2.1">If more values remain in inner_list, append a single SP to output.<a href="#section-4.1.1.1-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                </ol>
</li>
              <li id="section-4.1.1.1-2.3">
                <p id="section-4.1.1.1-2.3.1">Append ")" to output.<a href="#section-4.1.1.1-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.1-2.4">
                <p id="section-4.1.1.1-2.4.1">Append the result of running Serializing Parameters (<a href="#ser-params" class="auto internal xref">Section 4.1.1.2</a>) with list_parameters to output.<a href="#section-4.1.1.1-2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.1-2.5">
                <p id="section-4.1.1.1-2.5.1">Return output.<a href="#section-4.1.1.1-2.5.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="ser-params">
<section id="section-4.1.1.2">
            <h5 id="name-serializing-parameters">
<a href="#section-4.1.1.2" class="section-number selfRef">4.1.1.2. </a><a href="#name-serializing-parameters" class="section-name selfRef">Serializing Parameters</a>
            </h5>
<p id="section-4.1.1.2-1">Given an ordered Dictionary as input_parameters (each member having a param_key and a param_value), return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.1.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.2-2">
<li id="section-4.1.1.2-2.1">
                <p id="section-4.1.1.2-2.1.1">Let output be an empty string.<a href="#section-4.1.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.2-2.2">
                <p id="section-4.1.1.2-2.2.1">For each param_key with a value of param_value in input_parameters:<a href="#section-4.1.1.2-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.2-2.2.2">
<li id="section-4.1.1.2-2.2.2.1">
                    <p id="section-4.1.1.2-2.2.2.1.1">Append ";" to output.<a href="#section-4.1.1.2-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.1.1.2-2.2.2.2">
                    <p id="section-4.1.1.2-2.2.2.2.1">Append the result of running Serializing a Key (<a href="#ser-key" class="auto internal xref">Section 4.1.1.3</a>) with param_key to output.<a href="#section-4.1.1.2-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.1.1.2-2.2.2.3">
                    <p id="section-4.1.1.2-2.2.2.3.1">If param_value is not Boolean true:<a href="#section-4.1.1.2-2.2.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.2-2.2.2.3.2">
<li id="section-4.1.1.2-2.2.2.3.2.1">
                        <p id="section-4.1.1.2-2.2.2.3.2.1.1">Append "=" to output.<a href="#section-4.1.1.2-2.2.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                      <li id="section-4.1.1.2-2.2.2.3.2.2">
                        <p id="section-4.1.1.2-2.2.2.3.2.2.1">Append the result of running Serializing a bare Item (<a href="#ser-bare-item" class="auto internal xref">Section 4.1.3.1</a>) with param_value to output.<a href="#section-4.1.1.2-2.2.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                    </ol>
</li>
                </ol>
</li>
              <li id="section-4.1.1.2-2.3">
                <p id="section-4.1.1.2-2.3.1">Return output.<a href="#section-4.1.1.2-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="ser-key">
<section id="section-4.1.1.3">
            <h5 id="name-serializing-a-key">
<a href="#section-4.1.1.3" class="section-number selfRef">4.1.1.3. </a><a href="#name-serializing-a-key" class="section-name selfRef">Serializing a Key</a>
            </h5>
<p id="section-4.1.1.3-1">Given a key as input_key, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.1.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.1.3-2">
<li id="section-4.1.1.3-2.1">
                <p id="section-4.1.1.3-2.1.1">Convert input_key into a sequence of ASCII characters; if conversion fails, fail serialization.<a href="#section-4.1.1.3-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.3-2.2">
                <p id="section-4.1.1.3-2.2.1">If input_key contains characters not in lcalpha, DIGIT, "_", "-", ".", or "*", fail serialization.<a href="#section-4.1.1.3-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.3-2.3">
                <p id="section-4.1.1.3-2.3.1">If the first character of input_key is not lcalpha or "*", fail serialization.<a href="#section-4.1.1.3-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.3-2.4">
                <p id="section-4.1.1.3-2.4.1">Let output be an empty string.<a href="#section-4.1.1.3-2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.3-2.5">
                <p id="section-4.1.1.3-2.5.1">Append input_key to output.<a href="#section-4.1.1.3-2.5.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.1.3-2.6">
                <p id="section-4.1.1.3-2.6.1">Return output.<a href="#section-4.1.1.3-2.6.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
</section>
</div>
<div id="ser-dictionary">
<section id="section-4.1.2">
          <h4 id="name-serializing-a-dictionary">
<a href="#section-4.1.2" class="section-number selfRef">4.1.2. </a><a href="#name-serializing-a-dictionary" class="section-name selfRef">Serializing a Dictionary</a>
          </h4>
<p id="section-4.1.2-1">Given an ordered Dictionary as input_dictionary (each member having a member_key and a tuple value of (member_value, parameters)), return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-2">
<li id="section-4.1.2-2.1">
              <p id="section-4.1.2-2.1.1">Let output be an empty string.<a href="#section-4.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.2-2.2">
              <p id="section-4.1.2-2.2.1">For each member_key with a value of (member_value, parameters) in input_dictionary:<a href="#section-4.1.2-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-2.2.2">
<li id="section-4.1.2-2.2.2.1">
                  <p id="section-4.1.2-2.2.2.1.1">Append the result of running Serializing a Key (<a href="#ser-key" class="auto internal xref">Section 4.1.1.3</a>) with member's member_key to output.<a href="#section-4.1.2-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.1.2-2.2.2.2">
                  <p id="section-4.1.2-2.2.2.2.1">If member_value is Boolean true:<a href="#section-4.1.2-2.2.2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-2.2.2.2.2">
<li id="section-4.1.2-2.2.2.2.2.1">
                      <p id="section-4.1.2-2.2.2.2.2.1.1">Append the result of running Serializing Parameters (<a href="#ser-params" class="auto internal xref">Section 4.1.1.2</a>) with parameters to output.<a href="#section-4.1.2-2.2.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.1.2-2.2.2.3">
                  <p id="section-4.1.2-2.2.2.3.1">Otherwise:<a href="#section-4.1.2-2.2.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-2.2.2.3.2">
<li id="section-4.1.2-2.2.2.3.2.1">
                      <p id="section-4.1.2-2.2.2.3.2.1.1">Append "=" to output.<a href="#section-4.1.2-2.2.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.2-2.2.2.3.2.2">
                      <p id="section-4.1.2-2.2.2.3.2.2.1">If member_value is an array, append the result of running Serializing an Inner List (<a href="#ser-innerlist" class="auto internal xref">Section 4.1.1.1</a>) with (member_value, parameters) to output.<a href="#section-4.1.2-2.2.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.2-2.2.2.3.2.3">
                      <p id="section-4.1.2-2.2.2.3.2.3.1">Otherwise, append the result of running Serializing an Item (<a href="#ser-item" class="auto internal xref">Section 4.1.3</a>) with (member_value, parameters) to output.<a href="#section-4.1.2-2.2.2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.1.2-2.2.2.4">
                  <p id="section-4.1.2-2.2.2.4.1">If more members remain in input_dictionary:<a href="#section-4.1.2-2.2.2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.2-2.2.2.4.2">
<li id="section-4.1.2-2.2.2.4.2.1">
                      <p id="section-4.1.2-2.2.2.4.2.1.1">Append "," to output.<a href="#section-4.1.2-2.2.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.2-2.2.2.4.2.2">
                      <p id="section-4.1.2-2.2.2.4.2.2.1">Append a single SP to output.<a href="#section-4.1.2-2.2.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li id="section-4.1.2-2.3">
              <p id="section-4.1.2-2.3.1">Return output.<a href="#section-4.1.2-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-item">
<section id="section-4.1.3">
          <h4 id="name-serializing-an-item">
<a href="#section-4.1.3" class="section-number selfRef">4.1.3. </a><a href="#name-serializing-an-item" class="section-name selfRef">Serializing an Item</a>
          </h4>
<p id="section-4.1.3-1">Given an Item as bare_item and Parameters as item_parameters, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.3-2">
<li id="section-4.1.3-2.1">
              <p id="section-4.1.3-2.1.1">Let output be an empty string.<a href="#section-4.1.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.3-2.2">
              <p id="section-4.1.3-2.2.1">Append the result of running Serializing a Bare Item (<a href="#ser-bare-item" class="auto internal xref">Section 4.1.3.1</a>) with bare_item to output.<a href="#section-4.1.3-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.3-2.3">
              <p id="section-4.1.3-2.3.1">Append the result of running Serializing Parameters (<a href="#ser-params" class="auto internal xref">Section 4.1.1.2</a>) with item_parameters to output.<a href="#section-4.1.3-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.3-2.4">
              <p id="section-4.1.3-2.4.1">Return output.<a href="#section-4.1.3-2.4.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<div id="ser-bare-item">
<section id="section-4.1.3.1">
            <h5 id="name-serializing-a-bare-item">
<a href="#section-4.1.3.1" class="section-number selfRef">4.1.3.1. </a><a href="#name-serializing-a-bare-item" class="section-name selfRef">Serializing a Bare Item</a>
            </h5>
<p id="section-4.1.3.1-1">Given an Item as input_item, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.3.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.3.1-2">
<li id="section-4.1.3.1-2.1">
                <p id="section-4.1.3.1-2.1.1">If input_item is an Integer, return the result of running Serializing an Integer (<a href="#ser-integer" class="auto internal xref">Section 4.1.4</a>) with input_item.<a href="#section-4.1.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.2">
                <p id="section-4.1.3.1-2.2.1">If input_item is a Decimal, return the result of running Serializing a Decimal (<a href="#ser-decimal" class="auto internal xref">Section 4.1.5</a>) with input_item.<a href="#section-4.1.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.3">
                <p id="section-4.1.3.1-2.3.1">If input_item is a String, return the result of running Serializing a String (<a href="#ser-string" class="auto internal xref">Section 4.1.6</a>) with input_item.<a href="#section-4.1.3.1-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.4">
                <p id="section-4.1.3.1-2.4.1">If input_item is a Token, return the result of running Serializing a Token (<a href="#ser-token" class="auto internal xref">Section 4.1.7</a>) with input_item.<a href="#section-4.1.3.1-2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.5">
                <p id="section-4.1.3.1-2.5.1">If input_item is a Byte Sequence, return the result of running Serializing a Byte Sequence (<a href="#ser-binary" class="auto internal xref">Section 4.1.8</a>) with input_item.<a href="#section-4.1.3.1-2.5.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.6">
                <p id="section-4.1.3.1-2.6.1">If input_item is a Boolean, return the result of running Serializing a Boolean (<a href="#ser-boolean" class="auto internal xref">Section 4.1.9</a>) with input_item.<a href="#section-4.1.3.1-2.6.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.7">
                <p id="section-4.1.3.1-2.7.1">If input_item is a Date, return the result of running Serializing a Date (<a href="#ser-date" class="auto internal xref">Section 4.1.10</a>) with input_item.<a href="#section-4.1.3.1-2.7.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.8">
                <p id="section-4.1.3.1-2.8.1">If input_item is a Display String, return the result of running Serializing a Display String (<a href="#ser-display" class="auto internal xref">Section 4.1.11</a>) with input_item.<a href="#section-4.1.3.1-2.8.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.1.3.1-2.9">
                <p id="section-4.1.3.1-2.9.1">Otherwise, fail serialization.<a href="#section-4.1.3.1-2.9.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
</section>
</div>
<div id="ser-integer">
<section id="section-4.1.4">
          <h4 id="name-serializing-an-integer">
<a href="#section-4.1.4" class="section-number selfRef">4.1.4. </a><a href="#name-serializing-an-integer" class="section-name selfRef">Serializing an Integer</a>
          </h4>
<p id="section-4.1.4-1">Given an Integer as input_integer, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.4-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.4-2">
<li id="section-4.1.4-2.1">
              <p id="section-4.1.4-2.1.1">If input_integer is not an integer in the range of -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail serialization.<a href="#section-4.1.4-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.4-2.2">
              <p id="section-4.1.4-2.2.1">Let output be an empty string.<a href="#section-4.1.4-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.4-2.3">
              <p id="section-4.1.4-2.3.1">If input_integer is less than (but not equal to) 0, append "-" to output.<a href="#section-4.1.4-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.4-2.4">
              <p id="section-4.1.4-2.4.1">Append input_integer's numeric value represented in base 10 using only decimal digits to output.<a href="#section-4.1.4-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.4-2.5">
              <p id="section-4.1.4-2.5.1">Return output.<a href="#section-4.1.4-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-decimal">
<section id="section-4.1.5">
          <h4 id="name-serializing-a-decimal">
<a href="#section-4.1.5" class="section-number selfRef">4.1.5. </a><a href="#name-serializing-a-decimal" class="section-name selfRef">Serializing a Decimal</a>
          </h4>
<p id="section-4.1.5-1">Given a decimal number as input_decimal, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.5-2">
<li id="section-4.1.5-2.1">
              <p id="section-4.1.5-2.1.1">If input_decimal is not a decimal number, fail serialization.<a href="#section-4.1.5-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.2">
              <p id="section-4.1.5-2.2.1">If input_decimal has more than three significant digits to the right of the decimal point, round it to three decimal places, rounding the final digit to the nearest value, or to the even value if it is equidistant.<a href="#section-4.1.5-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.3">
              <p id="section-4.1.5-2.3.1">If input_decimal has more than 12 significant digits to the left of the decimal point after rounding, fail serialization.<a href="#section-4.1.5-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.4">
              <p id="section-4.1.5-2.4.1">Let output be an empty string.<a href="#section-4.1.5-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.5">
              <p id="section-4.1.5-2.5.1">If input_decimal is less than (but not equal to) 0, append "-" to output.<a href="#section-4.1.5-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.6">
              <p id="section-4.1.5-2.6.1">Append input_decimal's integer component represented in base 10 (using only decimal digits) to output; if it is zero, append "0".<a href="#section-4.1.5-2.6.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.7">
              <p id="section-4.1.5-2.7.1">Append "." to output.<a href="#section-4.1.5-2.7.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.8">
              <p id="section-4.1.5-2.8.1">If input_decimal's fractional component is zero, append "0" to output.<a href="#section-4.1.5-2.8.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.9">
              <p id="section-4.1.5-2.9.1">Otherwise, append the significant digits of input_decimal's fractional component represented in base 10 (using only decimal digits) to output.<a href="#section-4.1.5-2.9.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.5-2.10">
              <p id="section-4.1.5-2.10.1">Return output.<a href="#section-4.1.5-2.10.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-string">
<section id="section-4.1.6">
          <h4 id="name-serializing-a-string">
<a href="#section-4.1.6" class="section-number selfRef">4.1.6. </a><a href="#name-serializing-a-string" class="section-name selfRef">Serializing a String</a>
          </h4>
<p id="section-4.1.6-1">Given a String as input_string, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.6-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.6-2">
<li id="section-4.1.6-2.1">
              <p id="section-4.1.6-2.1.1">Convert input_string into a sequence of ASCII characters; if conversion fails, fail serialization.<a href="#section-4.1.6-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.6-2.2">
              <p id="section-4.1.6-2.2.1">If input_string contains characters in the range %x00-1f or %x7f-ff (i.e., not in VCHAR or SP), fail serialization.<a href="#section-4.1.6-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.6-2.3">
              <p id="section-4.1.6-2.3.1">Let output be the string DQUOTE.<a href="#section-4.1.6-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.6-2.4">
              <p id="section-4.1.6-2.4.1">For each character char in input_string:<a href="#section-4.1.6-2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.6-2.4.2">
<li id="section-4.1.6-2.4.2.1">
                  <p id="section-4.1.6-2.4.2.1.1">If char is "\" or DQUOTE:<a href="#section-4.1.6-2.4.2.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.6-2.4.2.1.2">
<li id="section-4.1.6-2.4.2.1.2.1">
                      <p id="section-4.1.6-2.4.2.1.2.1.1">Append "\" to output.<a href="#section-4.1.6-2.4.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.1.6-2.4.2.2">
                  <p id="section-4.1.6-2.4.2.2.1">Append char to output.<a href="#section-4.1.6-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.1.6-2.5">
              <p id="section-4.1.6-2.5.1">Append DQUOTE to output.<a href="#section-4.1.6-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.6-2.6">
              <p id="section-4.1.6-2.6.1">Return output.<a href="#section-4.1.6-2.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-token">
<section id="section-4.1.7">
          <h4 id="name-serializing-a-token">
<a href="#section-4.1.7" class="section-number selfRef">4.1.7. </a><a href="#name-serializing-a-token" class="section-name selfRef">Serializing a Token</a>
          </h4>
<p id="section-4.1.7-1">Given a Token as input_token, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.7-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.7-2">
<li id="section-4.1.7-2.1">
              <p id="section-4.1.7-2.1.1">Convert input_token into a sequence of ASCII characters; if conversion fails, fail serialization.<a href="#section-4.1.7-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.7-2.2">
              <p id="section-4.1.7-2.2.1">If the first character of input_token is not ALPHA or "*", or the remaining portion contains a character not in tchar, ":", or "/", fail serialization.<a href="#section-4.1.7-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.7-2.3">
              <p id="section-4.1.7-2.3.1">Let output be an empty string.<a href="#section-4.1.7-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.7-2.4">
              <p id="section-4.1.7-2.4.1">Append input_token to output.<a href="#section-4.1.7-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.7-2.5">
              <p id="section-4.1.7-2.5.1">Return output.<a href="#section-4.1.7-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-binary">
<section id="section-4.1.8">
          <h4 id="name-serializing-a-byte-sequence">
<a href="#section-4.1.8" class="section-number selfRef">4.1.8. </a><a href="#name-serializing-a-byte-sequence" class="section-name selfRef">Serializing a Byte Sequence</a>
          </h4>
<p id="section-4.1.8-1">Given a Byte Sequence as input_bytes, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.8-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.8-2">
<li id="section-4.1.8-2.1">
              <p id="section-4.1.8-2.1.1">If input_bytes is not a sequence of bytes, fail serialization.<a href="#section-4.1.8-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.8-2.2">
              <p id="section-4.1.8-2.2.1">Let output be an empty string.<a href="#section-4.1.8-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.8-2.3">
              <p id="section-4.1.8-2.3.1">Append ":" to output.<a href="#section-4.1.8-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.8-2.4">
              <p id="section-4.1.8-2.4.1">Append the result of base64-encoding input_bytes as per <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-4" class="relref">Section 4</a></span>, taking account of the requirements below.<a href="#section-4.1.8-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.8-2.5">
              <p id="section-4.1.8-2.5.1">Append ":" to output.<a href="#section-4.1.8-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.8-2.6">
              <p id="section-4.1.8-2.6.1">Return output.<a href="#section-4.1.8-2.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.1.8-3">The encoded data is required to be padded with "=", as per <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2" class="relref">Section 3.2</a></span>.<a href="#section-4.1.8-3" class="pilcrow">¶</a></p>
<p id="section-4.1.8-4">Likewise, encoded data SHOULD have pad bits set to zero, as per <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5" class="relref">Section 3.5</a></span>, unless it is not possible to do so due to implementation constraints.<a href="#section-4.1.8-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ser-boolean">
<section id="section-4.1.9">
          <h4 id="name-serializing-a-boolean">
<a href="#section-4.1.9" class="section-number selfRef">4.1.9. </a><a href="#name-serializing-a-boolean" class="section-name selfRef">Serializing a Boolean</a>
          </h4>
<p id="section-4.1.9-1">Given a Boolean as input_boolean, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.9-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.9-2">
<li id="section-4.1.9-2.1">
              <p id="section-4.1.9-2.1.1">If input_boolean is not a boolean, fail serialization.<a href="#section-4.1.9-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.9-2.2">
              <p id="section-4.1.9-2.2.1">Let output be an empty string.<a href="#section-4.1.9-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.9-2.3">
              <p id="section-4.1.9-2.3.1">Append "?" to output.<a href="#section-4.1.9-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.9-2.4">
              <p id="section-4.1.9-2.4.1">If input_boolean is true, append "1" to output.<a href="#section-4.1.9-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.9-2.5">
              <p id="section-4.1.9-2.5.1">If input_boolean is false, append "0" to output.<a href="#section-4.1.9-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.9-2.6">
              <p id="section-4.1.9-2.6.1">Return output.<a href="#section-4.1.9-2.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-date">
<section id="section-4.1.10">
          <h4 id="name-serializing-a-date">
<a href="#section-4.1.10" class="section-number selfRef">4.1.10. </a><a href="#name-serializing-a-date" class="section-name selfRef">Serializing a Date</a>
          </h4>
<p id="section-4.1.10-1">Given a Date as input_date, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.10-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.10-2">
<li id="section-4.1.10-2.1">
              <p id="section-4.1.10-2.1.1">Let output be "@".<a href="#section-4.1.10-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.10-2.2">
              <p id="section-4.1.10-2.2.1">Append to output the result of running Serializing an Integer with input_date (<a href="#ser-integer" class="auto internal xref">Section 4.1.4</a>).<a href="#section-4.1.10-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.10-2.3">
              <p id="section-4.1.10-2.3.1">Return output.<a href="#section-4.1.10-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="ser-display">
<section id="section-4.1.11">
          <h4 id="name-serializing-a-display-strin">
<a href="#section-4.1.11" class="section-number selfRef">4.1.11. </a><a href="#name-serializing-a-display-strin" class="section-name selfRef">Serializing a Display String</a>
          </h4>
<p id="section-4.1.11-1">Given a sequence of Unicode codepoints as input_sequence, return an ASCII string suitable for use in an HTTP field value.<a href="#section-4.1.11-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.11-2">
<li id="section-4.1.11-2.1">
              <p id="section-4.1.11-2.1.1">If input_sequence is not a sequence of Unicode codepoints, fail serialization.<a href="#section-4.1.11-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.11-2.2">
              <p id="section-4.1.11-2.2.1">Let byte_array be the result of applying UTF-8 encoding (<span><a href="https://rfc-editor.org/rfc/rfc3629#section-3" class="relref">Section 3</a> of [<a href="#UTF8" class="cite xref">UTF8</a>]</span>) to input_sequence. If encoding fails, fail serialization.<a href="#section-4.1.11-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.11-2.3">
              <p id="section-4.1.11-2.3.1">Let encoded_string be a string containing "%" followed by DQUOTE.<a href="#section-4.1.11-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.11-2.4">
              <p id="section-4.1.11-2.4.1">For each byte in byte_array:<a href="#section-4.1.11-2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.11-2.4.2">
<li id="section-4.1.11-2.4.2.1">
                  <p id="section-4.1.11-2.4.2.1.1">If byte is %x25 ("%"), %x22 (DQUOTE), or in the ranges %x00-1f or %x7f-ff:<a href="#section-4.1.11-2.4.2.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.1.11-2.4.2.1.2">
<li id="section-4.1.11-2.4.2.1.2.1">
                      <p id="section-4.1.11-2.4.2.1.2.1.1">Append "%" to encoded_string.<a href="#section-4.1.11-2.4.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.11-2.4.2.1.2.2">
                      <p id="section-4.1.11-2.4.2.1.2.2.1">Let encoded_byte be the result of applying base16 encoding (<span><a href="https://rfc-editor.org/rfc/rfc4648#section-8" class="relref">Section 8</a> of [<a href="#RFC4648" class="cite xref">RFC4648</a>]</span>) to byte, with any alphabetic characters converted to lowercase.<a href="#section-4.1.11-2.4.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.1.11-2.4.2.1.2.3">
                      <p id="section-4.1.11-2.4.2.1.2.3.1">Append encoded_byte to encoded_string.<a href="#section-4.1.11-2.4.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.1.11-2.4.2.2">
                  <p id="section-4.1.11-2.4.2.2.1">Otherwise, decode byte as an ASCII character and append the result to encoded_string.<a href="#section-4.1.11-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.1.11-2.5">
              <p id="section-4.1.11-2.5.1">Append DQUOTE to encoded_string.<a href="#section-4.1.11-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.1.11-2.6">
              <p id="section-4.1.11-2.6.1">Return encoded_string.<a href="#section-4.1.11-2.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.1.11-3">Note that <span>[<a href="#UTF8" class="cite xref">UTF8</a>]</span> prohibits the encoding of codepoints between U+D800 and U+DFFF (surrogates); if they occur in input_sequence, serialization will fail.<a href="#section-4.1.11-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="text-parse">
<section id="section-4.2">
        <h3 id="name-parsing-structured-fields">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-parsing-structured-fields" class="section-name selfRef">Parsing Structured Fields</a>
        </h3>
<p id="section-4.2-1">When a receiving implementation parses HTTP fields that are known to be Structured Fields, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">Given an array of bytes as input_bytes that represent the chosen field's field-value (which is empty if that field is not present) and field_type (one of "dictionary", "list", or "item"), return the parsed field value.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2-3">
<li id="section-4.2-3.1">
            <p id="section-4.2-3.1.1">Convert input_bytes into an ASCII string input_string; if conversion fails, fail parsing.<a href="#section-4.2-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.2">
            <p id="section-4.2-3.2.1">Discard any leading SP characters from input_string.<a href="#section-4.2-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.3">
            <p id="section-4.2-3.3.1">If field_type is "list", let output be the result of running Parsing a List (<a href="#parse-list" class="auto internal xref">Section 4.2.1</a>) with input_string.<a href="#section-4.2-3.3.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.4">
            <p id="section-4.2-3.4.1">If field_type is "dictionary", let output be the result of running Parsing a Dictionary (<a href="#parse-dictionary" class="auto internal xref">Section 4.2.2</a>) with input_string.<a href="#section-4.2-3.4.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.5">
            <p id="section-4.2-3.5.1">If field_type is "item", let output be the result of running Parsing an Item (<a href="#parse-item" class="auto internal xref">Section 4.2.3</a>) with input_string.<a href="#section-4.2-3.5.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.6">
            <p id="section-4.2-3.6.1">Discard any leading SP characters from input_string.<a href="#section-4.2-3.6.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.7">
            <p id="section-4.2-3.7.1">If input_string is not empty, fail parsing.<a href="#section-4.2-3.7.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-4.2-3.8">
            <p id="section-4.2-3.8.1">Otherwise, return output.<a href="#section-4.2-3.8.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-4.2-4">When generating input_bytes, parsers MUST combine all field lines in the same section (header or trailer) that case-insensitively match the field name into one comma-separated field-value, as per <span><a href="https://rfc-editor.org/rfc/rfc9110#section-5.2" class="relref">Section 5.2</a> of [<a href="#HTTP" class="cite xref">HTTP</a>]</span>; this assures that the entire field value is processed correctly.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2-5">For Lists and Dictionaries, this has the effect of correctly concatenating all of the field's lines, as long as individual members of the top-level data structure are not split across multiple field instances. The parsing algorithms for both types allow tab characters, since these might
be used to combine field lines by some implementations.<a href="#section-4.2-5" class="pilcrow">¶</a></p>
<p id="section-4.2-6">Strings split across multiple field lines will have unpredictable results, because one or more commas (with optional whitespace) will become part of the string output by the parser. Since concatenation might be done by an upstream intermediary, the results are not under the control of the serializer or the parser, even when they are both under the control of the same party.<a href="#section-4.2-6" class="pilcrow">¶</a></p>
<p id="section-4.2-7">Tokens, Integers, Decimals, and Byte Sequences cannot be split across multiple field lines because the inserted commas will cause parsing to fail.<a href="#section-4.2-7" class="pilcrow">¶</a></p>
<p id="section-4.2-8">Parsers MAY fail when processing a field value spread across multiple field lines, when one of those lines does not parse as that field. For example, a parsing handling an Example-String field that's defined as an sf-string is allowed to fail when processing this field section:<a href="#section-4.2-8" class="pilcrow">¶</a></p>
<div class="lang-http-message sourcecode" id="section-4.2-9">
<pre>
Example-String: "foo
Example-String: bar"
</pre><a href="#section-4.2-9" class="pilcrow">¶</a>
</div>
<p id="section-4.2-10">If parsing fails, either the entire field value MUST be ignored (i.e., treated as if the field were not present in the section), or alternatively the complete HTTP message MUST be treated as malformed. This is intentionally strict to improve interoperability and safety, and field specifications that use Structured Fields are not allowed to loosen this requirement.<a href="#section-4.2-10" class="pilcrow">¶</a></p>
<p id="section-4.2-11">Note that this requirement does not apply to an implementation that is not parsing the field; for example, an intermediary is not required to strip a failing field from a message before forwarding it.<a href="#section-4.2-11" class="pilcrow">¶</a></p>
<div id="parse-list">
<section id="section-4.2.1">
          <h4 id="name-parsing-a-list">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-parsing-a-list" class="section-name selfRef">Parsing a List</a>
          </h4>
<p id="section-4.2.1-1">Given an ASCII string as input_string, return an array of (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1-2">
<li id="section-4.2.1-2.1">
              <p id="section-4.2.1-2.1.1">Let members be an empty array.<a href="#section-4.2.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.1-2.2">
              <p id="section-4.2.1-2.2.1">While input_string is not empty:<a href="#section-4.2.1-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1-2.2.2">
<li id="section-4.2.1-2.2.2.1">
                  <p id="section-4.2.1-2.2.2.1.1">Append the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list" class="auto internal xref">Section 4.2.1.1</a>) with input_string to members.<a href="#section-4.2.1-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.1-2.2.2.2">
                  <p id="section-4.2.1-2.2.2.2.1">Discard any leading OWS characters from input_string.<a href="#section-4.2.1-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.1-2.2.2.3">
                  <p id="section-4.2.1-2.2.2.3.1">If input_string is empty, return members.<a href="#section-4.2.1-2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.1-2.2.2.4">
                  <p id="section-4.2.1-2.2.2.4.1">Consume the first character of input_string; if it is not ",", fail parsing.<a href="#section-4.2.1-2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.1-2.2.2.5">
                  <p id="section-4.2.1-2.2.2.5.1">Discard any leading OWS characters from input_string.<a href="#section-4.2.1-2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.1-2.2.2.6">
                  <p id="section-4.2.1-2.2.2.6.1">If input_string is empty, there is a trailing comma; fail parsing.<a href="#section-4.2.1-2.2.2.6.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.1-2.3">
              <p id="section-4.2.1-2.3.1">No structured data has been found; return members (which is empty).<a href="#section-4.2.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<div id="parse-item-or-list">
<section id="section-4.2.1.1">
            <h5 id="name-parsing-an-item-or-inner-li">
<a href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1. </a><a href="#name-parsing-an-item-or-inner-li" class="section-name selfRef">Parsing an Item or Inner List</a>
            </h5>
<p id="section-4.2.1.1-1">Given an ASCII string as input_string, return the tuple (item_or_inner_list, parameters), where item_or_inner_list can be either a single bare item or an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.<a href="#section-4.2.1.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1.1-2">
<li id="section-4.2.1.1-2.1">
                <p id="section-4.2.1.1-2.1.1">If the first character of input_string is "(", return the result of running Parsing an Inner List (<a href="#parse-innerlist" class="auto internal xref">Section 4.2.1.2</a>) with input_string.<a href="#section-4.2.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.1.1-2.2">
                <p id="section-4.2.1.1-2.2.1">Return the result of running Parsing an Item (<a href="#parse-item" class="auto internal xref">Section 4.2.3</a>) with input_string.<a href="#section-4.2.1.1-2.2.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="parse-innerlist">
<section id="section-4.2.1.2">
            <h5 id="name-parsing-an-inner-list">
<a href="#section-4.2.1.2" class="section-number selfRef">4.2.1.2. </a><a href="#name-parsing-an-inner-list" class="section-name selfRef">Parsing an Inner List</a>
            </h5>
<p id="section-4.2.1.2-1">Given an ASCII string as input_string, return the tuple (inner_list, parameters), where inner_list is an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.<a href="#section-4.2.1.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1.2-2">
<li id="section-4.2.1.2-2.1">
                <p id="section-4.2.1.2-2.1.1">Consume the first character of input_string; if it is not "(", fail parsing.<a href="#section-4.2.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.1.2-2.2">
                <p id="section-4.2.1.2-2.2.1">Let inner_list be an empty array.<a href="#section-4.2.1.2-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.1.2-2.3">
                <p id="section-4.2.1.2-2.3.1">While input_string is not empty:<a href="#section-4.2.1.2-2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1.2-2.3.2">
<li id="section-4.2.1.2-2.3.2.1">
                    <p id="section-4.2.1.2-2.3.2.1.1">Discard any leading SP characters from input_string.<a href="#section-4.2.1.2-2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.1.2-2.3.2.2">
                    <p id="section-4.2.1.2-2.3.2.2.1">If the first character of input_string is ")":<a href="#section-4.2.1.2-2.3.2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.1.2-2.3.2.2.2">
<li id="section-4.2.1.2-2.3.2.2.2.1">
                        <p id="section-4.2.1.2-2.3.2.2.2.1.1">Consume the first character of input_string.<a href="#section-4.2.1.2-2.3.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                      <li id="section-4.2.1.2-2.3.2.2.2.2">
                        <p id="section-4.2.1.2-2.3.2.2.2.2.1">Let parameters be the result of running Parsing Parameters (<a href="#parse-param" class="auto internal xref">Section 4.2.3.2</a>) with input_string.<a href="#section-4.2.1.2-2.3.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                      <li id="section-4.2.1.2-2.3.2.2.2.3">
                        <p id="section-4.2.1.2-2.3.2.2.2.3.1">Return the tuple (inner_list, parameters).<a href="#section-4.2.1.2-2.3.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                    </ol>
</li>
                  <li id="section-4.2.1.2-2.3.2.3">
                    <p id="section-4.2.1.2-2.3.2.3.1">Let item be the result of running Parsing an Item (<a href="#parse-item" class="auto internal xref">Section 4.2.3</a>) with input_string.<a href="#section-4.2.1.2-2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.1.2-2.3.2.4">
                    <p id="section-4.2.1.2-2.3.2.4.1">Append item to inner_list.<a href="#section-4.2.1.2-2.3.2.4.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.1.2-2.3.2.5">
                    <p id="section-4.2.1.2-2.3.2.5.1">If the first character of input_string is not SP or ")", fail parsing.<a href="#section-4.2.1.2-2.3.2.5.1" class="pilcrow">¶</a></p>
</li>
                </ol>
</li>
              <li id="section-4.2.1.2-2.4">
                <p id="section-4.2.1.2-2.4.1">The end of the Inner List was not found; fail parsing.<a href="#section-4.2.1.2-2.4.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
</section>
</div>
<div id="parse-dictionary">
<section id="section-4.2.2">
          <h4 id="name-parsing-a-dictionary">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-parsing-a-dictionary" class="section-name selfRef">Parsing a Dictionary</a>
          </h4>
<p id="section-4.2.2-1">Given an ASCII string as input_string, return an ordered map whose values are (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.2-2">
<li id="section-4.2.2-2.1">
              <p id="section-4.2.2-2.1.1">Let dictionary be an empty, ordered map.<a href="#section-4.2.2-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.2-2.2">
              <p id="section-4.2.2-2.2.1">While input_string is not empty:<a href="#section-4.2.2-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.2-2.2.2">
<li id="section-4.2.2-2.2.2.1">
                  <p id="section-4.2.2-2.2.2.1.1">Let this_key be the result of running Parsing a Key (<a href="#parse-key" class="auto internal xref">Section 4.2.3.3</a>) with input_string.<a href="#section-4.2.2-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.2">
                  <p id="section-4.2.2-2.2.2.2.1">If the first character of input_string is "=":<a href="#section-4.2.2-2.2.2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.2-2.2.2.2.2">
<li id="section-4.2.2-2.2.2.2.2.1">
                      <p id="section-4.2.2-2.2.2.2.2.1.1">Consume the first character of input_string.<a href="#section-4.2.2-2.2.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.2-2.2.2.2.2.2">
                      <p id="section-4.2.2-2.2.2.2.2.2.1">Let member be the result of running Parsing an Item or Inner List (<a href="#parse-item-or-list" class="auto internal xref">Section 4.2.1.1</a>) with input_string.<a href="#section-4.2.2-2.2.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.2-2.2.2.3">
                  <p id="section-4.2.2-2.2.2.3.1">Otherwise:<a href="#section-4.2.2-2.2.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.2-2.2.2.3.2">
<li id="section-4.2.2-2.2.2.3.2.1">
                      <p id="section-4.2.2-2.2.2.3.2.1.1">Let value be Boolean true.<a href="#section-4.2.2-2.2.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.2-2.2.2.3.2.2">
                      <p id="section-4.2.2-2.2.2.3.2.2.1">Let parameters be the result of running Parsing Parameters (<a href="#parse-param" class="auto internal xref">Section 4.2.3.2</a>) with input_string.<a href="#section-4.2.2-2.2.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.2-2.2.2.3.2.3">
                      <p id="section-4.2.2-2.2.2.3.2.3.1">Let member be the tuple (value, parameters).<a href="#section-4.2.2-2.2.2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.2-2.2.2.4">
                  <p id="section-4.2.2-2.2.2.4.1">If dictionary already contains a key this_key (comparing character for character), overwrite its value with member.<a href="#section-4.2.2-2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.5">
                  <p id="section-4.2.2-2.2.2.5.1">Otherwise, append key this_key with value member to dictionary.<a href="#section-4.2.2-2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.6">
                  <p id="section-4.2.2-2.2.2.6.1">Discard any leading OWS characters from input_string.<a href="#section-4.2.2-2.2.2.6.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.7">
                  <p id="section-4.2.2-2.2.2.7.1">If input_string is empty, return dictionary.<a href="#section-4.2.2-2.2.2.7.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.8">
                  <p id="section-4.2.2-2.2.2.8.1">Consume the first character of input_string; if it is not ",", fail parsing.<a href="#section-4.2.2-2.2.2.8.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.9">
                  <p id="section-4.2.2-2.2.2.9.1">Discard any leading OWS characters from input_string.<a href="#section-4.2.2-2.2.2.9.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.2-2.2.2.10">
                  <p id="section-4.2.2-2.2.2.10.1">If input_string is empty, there is a trailing comma; fail parsing.<a href="#section-4.2.2-2.2.2.10.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.2-2.3">
              <p id="section-4.2.2-2.3.1">No structured data has been found; return dictionary (which is empty).<a href="#section-4.2.2-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.2.2-3">Note that when duplicate Dictionary keys are encountered, all but the last instance are ignored.<a href="#section-4.2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parse-item">
<section id="section-4.2.3">
          <h4 id="name-parsing-an-item">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-parsing-an-item" class="section-name selfRef">Parsing an Item</a>
          </h4>
<p id="section-4.2.3-1">Given an ASCII string as input_string, return a (bare_item, parameters) tuple. input_string is modified to remove the parsed value.<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3-2">
<li id="section-4.2.3-2.1">
              <p id="section-4.2.3-2.1.1">Let bare_item be the result of running Parsing a Bare Item (<a href="#parse-bare-item" class="auto internal xref">Section 4.2.3.1</a>) with input_string.<a href="#section-4.2.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.3-2.2">
              <p id="section-4.2.3-2.2.1">Let parameters be the result of running Parsing Parameters (<a href="#parse-param" class="auto internal xref">Section 4.2.3.2</a>) with input_string.<a href="#section-4.2.3-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.3-2.3">
              <p id="section-4.2.3-2.3.1">Return the tuple (bare_item, parameters).<a href="#section-4.2.3-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<div id="parse-bare-item">
<section id="section-4.2.3.1">
            <h5 id="name-parsing-a-bare-item">
<a href="#section-4.2.3.1" class="section-number selfRef">4.2.3.1. </a><a href="#name-parsing-a-bare-item" class="section-name selfRef">Parsing a Bare Item</a>
            </h5>
<p id="section-4.2.3.1-1">Given an ASCII string as input_string, return a bare Item. input_string is modified to remove the parsed value.<a href="#section-4.2.3.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.1-2">
<li id="section-4.2.3.1-2.1">
                <p id="section-4.2.3.1-2.1.1">If the first character of input_string is a "-" or a DIGIT, return the result of running Parsing an Integer or Decimal (<a href="#parse-number" class="auto internal xref">Section 4.2.4</a>) with input_string.<a href="#section-4.2.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.2">
                <p id="section-4.2.3.1-2.2.1">If the first character of input_string is a DQUOTE, return the result of running Parsing a String (<a href="#parse-string" class="auto internal xref">Section 4.2.5</a>) with input_string.<a href="#section-4.2.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.3">
                <p id="section-4.2.3.1-2.3.1">If the first character of input_string is an ALPHA or "*", return the result of running Parsing a Token (<a href="#parse-token" class="auto internal xref">Section 4.2.6</a>) with input_string.<a href="#section-4.2.3.1-2.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.4">
                <p id="section-4.2.3.1-2.4.1">If the first character of input_string is ":", return the result of running Parsing a Byte Sequence (<a href="#parse-binary" class="auto internal xref">Section 4.2.7</a>) with input_string.<a href="#section-4.2.3.1-2.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.5">
                <p id="section-4.2.3.1-2.5.1">If the first character of input_string is "?", return the result of running Parsing a Boolean (<a href="#parse-boolean" class="auto internal xref">Section 4.2.8</a>) with input_string.<a href="#section-4.2.3.1-2.5.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.6">
                <p id="section-4.2.3.1-2.6.1">If the first character of input_string is "@", return the result of running Parsing a Date (<a href="#parse-date" class="auto internal xref">Section 4.2.9</a>) with input_string.<a href="#section-4.2.3.1-2.6.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.7">
                <p id="section-4.2.3.1-2.7.1">If the first character of input_string is "%", return the result of running Parsing a Display String (<a href="#parse-display" class="auto internal xref">Section 4.2.10</a>) with input_string.<a href="#section-4.2.3.1-2.7.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.1-2.8">
                <p id="section-4.2.3.1-2.8.1">Otherwise, the item type is unrecognized; fail parsing.<a href="#section-4.2.3.1-2.8.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="parse-param">
<section id="section-4.2.3.2">
            <h5 id="name-parsing-parameters">
<a href="#section-4.2.3.2" class="section-number selfRef">4.2.3.2. </a><a href="#name-parsing-parameters" class="section-name selfRef">Parsing Parameters</a>
            </h5>
<p id="section-4.2.3.2-1">Given an ASCII string as input_string, return an ordered map whose values are bare Items. input_string is modified to remove the parsed value.<a href="#section-4.2.3.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.2-2">
<li id="section-4.2.3.2-2.1">
                <p id="section-4.2.3.2-2.1.1">Let parameters be an empty, ordered map.<a href="#section-4.2.3.2-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.2-2.2">
                <p id="section-4.2.3.2-2.2.1">While input_string is not empty:<a href="#section-4.2.3.2-2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.2-2.2.2">
<li id="section-4.2.3.2-2.2.2.1">
                    <p id="section-4.2.3.2-2.2.2.1.1">If the first character of input_string is not ";", exit the loop.<a href="#section-4.2.3.2-2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.2">
                    <p id="section-4.2.3.2-2.2.2.2.1">Consume the ";" character from the beginning of input_string.<a href="#section-4.2.3.2-2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.3">
                    <p id="section-4.2.3.2-2.2.2.3.1">Discard any leading SP characters from input_string.<a href="#section-4.2.3.2-2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.4">
                    <p id="section-4.2.3.2-2.2.2.4.1">Let param_key be the result of running Parsing a Key (<a href="#parse-key" class="auto internal xref">Section 4.2.3.3</a>) with input_string.<a href="#section-4.2.3.2-2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.5">
                    <p id="section-4.2.3.2-2.2.2.5.1">Let param_value be Boolean true.<a href="#section-4.2.3.2-2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.6">
                    <p id="section-4.2.3.2-2.2.2.6.1">If the first character of input_string is "=":<a href="#section-4.2.3.2-2.2.2.6.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.2-2.2.2.6.2">
<li id="section-4.2.3.2-2.2.2.6.2.1">
                        <p id="section-4.2.3.2-2.2.2.6.2.1.1">Consume the "=" character at the beginning of input_string.<a href="#section-4.2.3.2-2.2.2.6.2.1.1" class="pilcrow">¶</a></p>
</li>
                      <li id="section-4.2.3.2-2.2.2.6.2.2">
                        <p id="section-4.2.3.2-2.2.2.6.2.2.1">Let param_value be the result of running Parsing a Bare Item (<a href="#parse-bare-item" class="auto internal xref">Section 4.2.3.1</a>) with input_string.<a href="#section-4.2.3.2-2.2.2.6.2.2.1" class="pilcrow">¶</a></p>
</li>
                    </ol>
</li>
                  <li id="section-4.2.3.2-2.2.2.7">
                    <p id="section-4.2.3.2-2.2.2.7.1">If parameters already contains a key param_key (comparing character for character), overwrite its value with param_value.<a href="#section-4.2.3.2-2.2.2.7.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.2-2.2.2.8">
                    <p id="section-4.2.3.2-2.2.2.8.1">Otherwise, append key param_key with value param_value to parameters.<a href="#section-4.2.3.2-2.2.2.8.1" class="pilcrow">¶</a></p>
</li>
                </ol>
</li>
              <li id="section-4.2.3.2-2.3">
                <p id="section-4.2.3.2-2.3.1">Return parameters.<a href="#section-4.2.3.2-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-4.2.3.2-3">Note that when duplicate parameter keys are encountered, all but the last instance are ignored.<a href="#section-4.2.3.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parse-key">
<section id="section-4.2.3.3">
            <h5 id="name-parsing-a-key">
<a href="#section-4.2.3.3" class="section-number selfRef">4.2.3.3. </a><a href="#name-parsing-a-key" class="section-name selfRef">Parsing a Key</a>
            </h5>
<p id="section-4.2.3.3-1">Given an ASCII string as input_string, return a key. input_string is modified to remove the parsed value.<a href="#section-4.2.3.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.3-2">
<li id="section-4.2.3.3-2.1">
                <p id="section-4.2.3.3-2.1.1">If the first character of input_string is not lcalpha or "*", fail parsing.<a href="#section-4.2.3.3-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.3-2.2">
                <p id="section-4.2.3.3-2.2.1">Let output_string be an empty string.<a href="#section-4.2.3.3-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-4.2.3.3-2.3">
                <p id="section-4.2.3.3-2.3.1">While input_string is not empty:<a href="#section-4.2.3.3-2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.3.3-2.3.2">
<li id="section-4.2.3.3-2.3.2.1">
                    <p id="section-4.2.3.3-2.3.2.1.1">If the first character of input_string is not one of lcalpha, DIGIT, "_", "-", ".", or "*", return output_string.<a href="#section-4.2.3.3-2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.3-2.3.2.2">
                    <p id="section-4.2.3.3-2.3.2.2.1">Let char be the result of consuming the first character of input_string.<a href="#section-4.2.3.3-2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li id="section-4.2.3.3-2.3.2.3">
                    <p id="section-4.2.3.3-2.3.2.3.1">Append char to output_string.<a href="#section-4.2.3.3-2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ol>
</li>
              <li id="section-4.2.3.3-2.4">
                <p id="section-4.2.3.3-2.4.1">Return output_string.<a href="#section-4.2.3.3-2.4.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
</section>
</div>
<div id="parse-number">
<section id="section-4.2.4">
          <h4 id="name-parsing-an-integer-or-decim">
<a href="#section-4.2.4" class="section-number selfRef">4.2.4. </a><a href="#name-parsing-an-integer-or-decim" class="section-name selfRef">Parsing an Integer or Decimal</a>
          </h4>
<p id="section-4.2.4-1">Given an ASCII string as input_string, return an Integer or Decimal. input_string is modified to remove the parsed value.<a href="#section-4.2.4-1" class="pilcrow">¶</a></p>
<p id="section-4.2.4-2">NOTE: This algorithm parses both Integers (<a href="#integer" class="auto internal xref">Section 3.3.1</a>) and Decimals (<a href="#decimal" class="auto internal xref">Section 3.3.2</a>), and returns the corresponding structure.<a href="#section-4.2.4-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.4-3">
<li id="section-4.2.4-3.1">
              <p id="section-4.2.4-3.1.1">Let type be "integer".<a href="#section-4.2.4-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.2">
              <p id="section-4.2.4-3.2.1">Let sign be 1.<a href="#section-4.2.4-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.3">
              <p id="section-4.2.4-3.3.1">Let input_number be an empty string.<a href="#section-4.2.4-3.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.4">
              <p id="section-4.2.4-3.4.1">If the first character of input_string is "-", consume it and set sign to -1.<a href="#section-4.2.4-3.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.5">
              <p id="section-4.2.4-3.5.1">If input_string is empty, there is an empty integer; fail parsing.<a href="#section-4.2.4-3.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.6">
              <p id="section-4.2.4-3.6.1">If the first character of input_string is not a DIGIT, fail parsing.<a href="#section-4.2.4-3.6.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.7">
              <p id="section-4.2.4-3.7.1">While input_string is not empty:<a href="#section-4.2.4-3.7.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.4-3.7.2">
<li id="section-4.2.4-3.7.2.1">
                  <p id="section-4.2.4-3.7.2.1.1">Let char be the result of consuming the first character of input_string.<a href="#section-4.2.4-3.7.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.7.2.2">
                  <p id="section-4.2.4-3.7.2.2.1">If char is a DIGIT, append it to input_number.<a href="#section-4.2.4-3.7.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.7.2.3">
                  <p id="section-4.2.4-3.7.2.3.1">Else, if type is "integer" and char is ".":<a href="#section-4.2.4-3.7.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.4-3.7.2.3.2">
<li id="section-4.2.4-3.7.2.3.2.1">
                      <p id="section-4.2.4-3.7.2.3.2.1.1">If input_number contains more than 12 characters, fail parsing.<a href="#section-4.2.4-3.7.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.4-3.7.2.3.2.2">
                      <p id="section-4.2.4-3.7.2.3.2.2.1">Otherwise, append char to input_number and set type to "decimal".<a href="#section-4.2.4-3.7.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.4-3.7.2.4">
                  <p id="section-4.2.4-3.7.2.4.1">Otherwise, prepend char to input_string, and exit the loop.<a href="#section-4.2.4-3.7.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.7.2.5">
                  <p id="section-4.2.4-3.7.2.5.1">If type is "integer" and input_number contains more than 15 characters, fail parsing.<a href="#section-4.2.4-3.7.2.5.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.7.2.6">
                  <p id="section-4.2.4-3.7.2.6.1">If type is "decimal" and input_number contains more than 16 characters, fail parsing.<a href="#section-4.2.4-3.7.2.6.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.4-3.8">
              <p id="section-4.2.4-3.8.1">If type is "integer":<a href="#section-4.2.4-3.8.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.4-3.8.2">
<li id="section-4.2.4-3.8.2.1">
                  <p id="section-4.2.4-3.8.2.1.1">Let output_number be an Integer that is the result of parsing input_number as an integer.<a href="#section-4.2.4-3.8.2.1.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.4-3.9">
              <p id="section-4.2.4-3.9.1">Otherwise:<a href="#section-4.2.4-3.9.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.4-3.9.2">
<li id="section-4.2.4-3.9.2.1">
                  <p id="section-4.2.4-3.9.2.1.1">If the final character of input_number is ".", fail parsing.<a href="#section-4.2.4-3.9.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.9.2.2">
                  <p id="section-4.2.4-3.9.2.2.1">If the number of characters after "." in input_number is greater than three, fail parsing.<a href="#section-4.2.4-3.9.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.4-3.9.2.3">
                  <p id="section-4.2.4-3.9.2.3.1">Let output_number be a Decimal that is the result of parsing input_number as a decimal number.<a href="#section-4.2.4-3.9.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.4-3.10">
              <p id="section-4.2.4-3.10.1">Let output_number be the product of output_number and sign.<a href="#section-4.2.4-3.10.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.4-3.11">
              <p id="section-4.2.4-3.11.1">Return output_number.<a href="#section-4.2.4-3.11.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="parse-string">
<section id="section-4.2.5">
          <h4 id="name-parsing-a-string">
<a href="#section-4.2.5" class="section-number selfRef">4.2.5. </a><a href="#name-parsing-a-string" class="section-name selfRef">Parsing a String</a>
          </h4>
<p id="section-4.2.5-1">Given an ASCII string as input_string, return an unquoted String. input_string is modified to remove the parsed value.<a href="#section-4.2.5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.5-2">
<li id="section-4.2.5-2.1">
              <p id="section-4.2.5-2.1.1">Let output_string be an empty string.<a href="#section-4.2.5-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.5-2.2">
              <p id="section-4.2.5-2.2.1">If the first character of input_string is not DQUOTE, fail parsing.<a href="#section-4.2.5-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.5-2.3">
              <p id="section-4.2.5-2.3.1">Discard the first character of input_string.<a href="#section-4.2.5-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.5-2.4">
              <p id="section-4.2.5-2.4.1">While input_string is not empty:<a href="#section-4.2.5-2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.5-2.4.2">
<li id="section-4.2.5-2.4.2.1">
                  <p id="section-4.2.5-2.4.2.1.1">Let char be the result of consuming the first character of input_string.<a href="#section-4.2.5-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.5-2.4.2.2">
                  <p id="section-4.2.5-2.4.2.2.1">If char is a backslash ("\"):<a href="#section-4.2.5-2.4.2.2.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.5-2.4.2.2.2">
<li id="section-4.2.5-2.4.2.2.2.1">
                      <p id="section-4.2.5-2.4.2.2.2.1.1">If input_string is now empty, fail parsing.<a href="#section-4.2.5-2.4.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.5-2.4.2.2.2.2">
                      <p id="section-4.2.5-2.4.2.2.2.2.1">Let next_char be the result of consuming the first character of input_string.<a href="#section-4.2.5-2.4.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.5-2.4.2.2.2.3">
                      <p id="section-4.2.5-2.4.2.2.2.3.1">If next_char is not DQUOTE or "\", fail parsing.<a href="#section-4.2.5-2.4.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.5-2.4.2.2.2.4">
                      <p id="section-4.2.5-2.4.2.2.2.4.1">Append next_char to output_string.<a href="#section-4.2.5-2.4.2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.5-2.4.2.3">
                  <p id="section-4.2.5-2.4.2.3.1">Else, if char is DQUOTE, return output_string.<a href="#section-4.2.5-2.4.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.5-2.4.2.4">
                  <p id="section-4.2.5-2.4.2.4.1">Else, if char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.<a href="#section-4.2.5-2.4.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.5-2.4.2.5">
                  <p id="section-4.2.5-2.4.2.5.1">Else, append char to output_string.<a href="#section-4.2.5-2.4.2.5.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.5-2.5">
              <p id="section-4.2.5-2.5.1">Reached the end of input_string without finding a closing DQUOTE; fail parsing.<a href="#section-4.2.5-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="parse-token">
<section id="section-4.2.6">
          <h4 id="name-parsing-a-token">
<a href="#section-4.2.6" class="section-number selfRef">4.2.6. </a><a href="#name-parsing-a-token" class="section-name selfRef">Parsing a Token</a>
          </h4>
<p id="section-4.2.6-1">Given an ASCII string as input_string, return a Token. input_string is modified to remove the parsed value.<a href="#section-4.2.6-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.6-2">
<li id="section-4.2.6-2.1">
              <p id="section-4.2.6-2.1.1">If the first character of input_string is not ALPHA or "*", fail parsing.<a href="#section-4.2.6-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.6-2.2">
              <p id="section-4.2.6-2.2.1">Let output_string be an empty string.<a href="#section-4.2.6-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.6-2.3">
              <p id="section-4.2.6-2.3.1">While input_string is not empty:<a href="#section-4.2.6-2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.6-2.3.2">
<li id="section-4.2.6-2.3.2.1">
                  <p id="section-4.2.6-2.3.2.1.1">If the first character of input_string is not in tchar, ":", or "/", return output_string.<a href="#section-4.2.6-2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.6-2.3.2.2">
                  <p id="section-4.2.6-2.3.2.2.1">Let char be the result of consuming the first character of input_string.<a href="#section-4.2.6-2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.6-2.3.2.3">
                  <p id="section-4.2.6-2.3.2.3.1">Append char to output_string.<a href="#section-4.2.6-2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ol>
</li>
            <li id="section-4.2.6-2.4">
              <p id="section-4.2.6-2.4.1">Return output_string.<a href="#section-4.2.6-2.4.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="parse-binary">
<section id="section-4.2.7">
          <h4 id="name-parsing-a-byte-sequence">
<a href="#section-4.2.7" class="section-number selfRef">4.2.7. </a><a href="#name-parsing-a-byte-sequence" class="section-name selfRef">Parsing a Byte Sequence</a>
          </h4>
<p id="section-4.2.7-1">Given an ASCII string as input_string, return a Byte Sequence. input_string is modified to remove the parsed value.<a href="#section-4.2.7-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.7-2">
<li id="section-4.2.7-2.1">
              <p id="section-4.2.7-2.1.1">If the first character of input_string is not ":", fail parsing.<a href="#section-4.2.7-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.2">
              <p id="section-4.2.7-2.2.1">Discard the first character of input_string.<a href="#section-4.2.7-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.3">
              <p id="section-4.2.7-2.3.1">If there is not a ":" character before the end of input_string, fail parsing.<a href="#section-4.2.7-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.4">
              <p id="section-4.2.7-2.4.1">Let b64_content be the result of consuming content of input_string up to but not including the first instance of the character ":".<a href="#section-4.2.7-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.5">
              <p id="section-4.2.7-2.5.1">Consume the ":" character at the beginning of input_string.<a href="#section-4.2.7-2.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.6">
              <p id="section-4.2.7-2.6.1">If b64_content contains a character not included in ALPHA, DIGIT, "+", "/", and "=", fail parsing.<a href="#section-4.2.7-2.6.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.7">
              <p id="section-4.2.7-2.7.1">Let binary_content be the result of base64-decoding <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>]</span> b64_content, synthesizing padding if necessary (note the requirements about recipient behavior below). If base64 decoding fails, parsing fails.<a href="#section-4.2.7-2.7.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.7-2.8">
              <p id="section-4.2.7-2.8.1">Return binary_content.<a href="#section-4.2.7-2.8.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-4.2.7-3">Because some implementations of base64 do not allow rejection of encoded data that is not properly "=" padded (see <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.2" class="relref">Section 3.2</a></span>), parsers SHOULD NOT fail when "=" padding is not present, unless they cannot be configured to do so.<a href="#section-4.2.7-3" class="pilcrow">¶</a></p>
<p id="section-4.2.7-4">Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>], <a href="https://rfc-editor.org/rfc/rfc4648#section-3.5" class="relref">Section 3.5</a></span>), parsers SHOULD NOT fail when non-zero pad bits are present, unless they cannot be configured to do so.<a href="#section-4.2.7-4" class="pilcrow">¶</a></p>
<p id="section-4.2.7-5">This specification does not relax the requirements in Sections <a href="https://rfc-editor.org/rfc/rfc4648#section-3.1" class="relref">3.1</a> and <a href="https://rfc-editor.org/rfc/rfc4648#section-3.3" class="relref">3.3</a> of <span>[<a href="#RFC4648" class="cite xref">RFC4648</a>]</span>; therefore, parsers MUST fail on characters outside the base64 alphabet and on line feeds in encoded data.<a href="#section-4.2.7-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parse-boolean">
<section id="section-4.2.8">
          <h4 id="name-parsing-a-boolean">
<a href="#section-4.2.8" class="section-number selfRef">4.2.8. </a><a href="#name-parsing-a-boolean" class="section-name selfRef">Parsing a Boolean</a>
          </h4>
<p id="section-4.2.8-1">Given an ASCII string as input_string, return a Boolean. input_string is modified to remove the parsed value.<a href="#section-4.2.8-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.8-2">
<li id="section-4.2.8-2.1">
              <p id="section-4.2.8-2.1.1">If the first character of input_string is not "?", fail parsing.<a href="#section-4.2.8-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.8-2.2">
              <p id="section-4.2.8-2.2.1">Discard the first character of input_string.<a href="#section-4.2.8-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.8-2.3">
              <p id="section-4.2.8-2.3.1">If the first character of input_string matches "1", discard the first character, and return true.<a href="#section-4.2.8-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.8-2.4">
              <p id="section-4.2.8-2.4.1">If the first character of input_string matches "0", discard the first character, and return false.<a href="#section-4.2.8-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.8-2.5">
              <p id="section-4.2.8-2.5.1">No value has matched; fail parsing.<a href="#section-4.2.8-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="parse-date">
<section id="section-4.2.9">
          <h4 id="name-parsing-a-date">
<a href="#section-4.2.9" class="section-number selfRef">4.2.9. </a><a href="#name-parsing-a-date" class="section-name selfRef">Parsing a Date</a>
          </h4>
<p id="section-4.2.9-1">Given an ASCII string as input_string, return a Date. input_string is modified to remove the parsed value.<a href="#section-4.2.9-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.9-2">
<li id="section-4.2.9-2.1">
              <p id="section-4.2.9-2.1.1">If the first character of input_string is not "@", fail parsing.<a href="#section-4.2.9-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.9-2.2">
              <p id="section-4.2.9-2.2.1">Discard the first character of input_string.<a href="#section-4.2.9-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.9-2.3">
              <p id="section-4.2.9-2.3.1">Let output_date be the result of running Parsing an Integer or Decimal (<a href="#parse-number" class="auto internal xref">Section 4.2.4</a>) with input_string.<a href="#section-4.2.9-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.9-2.4">
              <p id="section-4.2.9-2.4.1">If output_date is a Decimal, fail parsing.<a href="#section-4.2.9-2.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.9-2.5">
              <p id="section-4.2.9-2.5.1">Return output_date.<a href="#section-4.2.9-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
<div id="parse-display">
<section id="section-4.2.10">
          <h4 id="name-parsing-a-display-string">
<a href="#section-4.2.10" class="section-number selfRef">4.2.10. </a><a href="#name-parsing-a-display-string" class="section-name selfRef">Parsing a Display String</a>
          </h4>
<p id="section-4.2.10-1">Given an ASCII string as input_string, return a sequence of Unicode codepoints. input_string is modified to remove the parsed value.<a href="#section-4.2.10-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.10-2">
<li id="section-4.2.10-2.1">
              <p id="section-4.2.10-2.1.1">If the first two characters of input_string are not "%" followed by DQUOTE, fail parsing.<a href="#section-4.2.10-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.10-2.2">
              <p id="section-4.2.10-2.2.1">Discard the first two characters of input_string.<a href="#section-4.2.10-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.10-2.3">
              <p id="section-4.2.10-2.3.1">Let byte_array be an empty byte array.<a href="#section-4.2.10-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-4.2.10-2.4">
              <p id="section-4.2.10-2.4.1">While input_string is not empty:<a href="#section-4.2.10-2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.10-2.4.2">
<li id="section-4.2.10-2.4.2.1">
                  <p id="section-4.2.10-2.4.2.1.1">Let char be the result of consuming the first character of input_string.<a href="#section-4.2.10-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.10-2.4.2.2">
                  <p id="section-4.2.10-2.4.2.2.1">If char is in the range %x00-1f or %x7f-ff (i.e., it is not in VCHAR or SP), fail parsing.<a href="#section-4.2.10-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li id="section-4.2.10-2.4.2.3">
                  <p id="section-4.2.10-2.4.2.3.1">If char is "%":<a href="#section-4.2.10-2.4.2.3.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.10-2.4.2.3.2">
<li id="section-4.2.10-2.4.2.3.2.1">
                      <p id="section-4.2.10-2.4.2.3.2.1.1">Let octet_hex be the result of consuming two characters from input_string. If there are not two characters, fail parsing.<a href="#section-4.2.10-2.4.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.10-2.4.2.3.2.2">
                      <p id="section-4.2.10-2.4.2.3.2.2.1">If octet_hex contains characters outside the range %x30-39 or %x61-66 (i.e., it is not in 0-9 or lowercase a-f), fail parsing.<a href="#section-4.2.10-2.4.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.10-2.4.2.3.2.3">
                      <p id="section-4.2.10-2.4.2.3.2.3.1">Let octet be the result of hex decoding octet_hex (<span><a href="https://rfc-editor.org/rfc/rfc4648#section-8" class="relref">Section 8</a> of [<a href="#RFC4648" class="cite xref">RFC4648</a>]</span>).<a href="#section-4.2.10-2.4.2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.10-2.4.2.3.2.4">
                      <p id="section-4.2.10-2.4.2.3.2.4.1">Append octet to byte_array.<a href="#section-4.2.10-2.4.2.3.2.4.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.10-2.4.2.4">
                  <p id="section-4.2.10-2.4.2.4.1">If char is DQUOTE:<a href="#section-4.2.10-2.4.2.4.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.10-2.4.2.4.2">
<li id="section-4.2.10-2.4.2.4.2.1">
                      <p id="section-4.2.10-2.4.2.4.2.1.1">Let unicode_sequence be the result of decoding byte_array as a UTF-8 string (<span><a href="https://rfc-editor.org/rfc/rfc3629#section-3" class="relref">Section 3</a> of [<a href="#UTF8" class="cite xref">UTF8</a>]</span>). Fail parsing if decoding fails.<a href="#section-4.2.10-2.4.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.10-2.4.2.4.2.2">
                      <p id="section-4.2.10-2.4.2.4.2.2.1">Return unicode_sequence.<a href="#section-4.2.10-2.4.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
                <li id="section-4.2.10-2.4.2.5">
                  <p id="section-4.2.10-2.4.2.5.1">Otherwise, if char is not "%" or DQUOTE:<a href="#section-4.2.10-2.4.2.5.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-4.2.10-2.4.2.5.2">
<li id="section-4.2.10-2.4.2.5.2.1">
                      <p id="section-4.2.10-2.4.2.5.2.1.1">Let byte be the result of applying ASCII encoding to char.<a href="#section-4.2.10-2.4.2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
                    <li id="section-4.2.10-2.4.2.5.2.2">
                      <p id="section-4.2.10-2.4.2.5.2.2.1">Append byte to byte_array.<a href="#section-4.2.10-2.4.2.5.2.2.1" class="pilcrow">¶</a></p>
</li>
                  </ol>
</li>
              </ol>
</li>
            <li id="section-4.2.10-2.5">
              <p id="section-4.2.10-2.5.1">Reached the end of input_string without finding a closing DQUOTE; fail parsing.<a href="#section-4.2.10-2.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="iana">
<section id="section-5">
      <h2 id="name-iana-considerations">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-5-1">Please add the following note to the "Hypertext Transfer Protocol (HTTP) Field Name Registry":<a href="#section-5-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-5-2.1">
          <p id="section-5-2.1.1">The "Structured Type" column indicates the type of the field (per RFC nnnn), if any, and may be
"Dictionary", "List" or "Item".<a href="#section-5-2.1.1" class="pilcrow">¶</a></p>
<p id="section-5-2.1.2">Note that field names beginning with characters other than ALPHA or "*" will not be able to be
represented as a Structured Fields Token, and therefore may be incompatible with being mapped into
field values that refer to it.<a href="#section-5-2.1.2" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-5-3">Then, add a new column, "Structured Type".<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">Then, add the indicated Structured Type for each existing registry entry listed in <a href="#existing-fields" class="auto internal xref">Table 1</a>.<a href="#section-5-4" class="pilcrow">¶</a></p>
<span id="name-existing-fields"></span><div id="existing-fields">
<table class="center" id="table-1">
        <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-existing-fields" class="selfRef">Existing Fields</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Field Name</th>
            <th class="text-left" rowspan="1" colspan="1">Structured Type</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Accept-CH</td>
            <td class="text-left" rowspan="1" colspan="1">List</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Cache-Status</td>
            <td class="text-left" rowspan="1" colspan="1">List</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">CDN-Cache-Control</td>
            <td class="text-left" rowspan="1" colspan="1">Dictionary</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Cross-Origin-Embedder-Policy</td>
            <td class="text-left" rowspan="1" colspan="1">Item</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Cross-Origin-Embedder-Policy-Report-Only</td>
            <td class="text-left" rowspan="1" colspan="1">Item</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Cross-Origin-Opener-Policy</td>
            <td class="text-left" rowspan="1" colspan="1">Item</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Cross-Origin-Opener-Policy-Report-Only</td>
            <td class="text-left" rowspan="1" colspan="1">Item</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Origin-Agent-Cluster</td>
            <td class="text-left" rowspan="1" colspan="1">Item</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Priority</td>
            <td class="text-left" rowspan="1" colspan="1">Dictionary</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">Proxy-Status</td>
            <td class="text-left" rowspan="1" colspan="1">List</td>
          </tr>
        </tbody>
      </table>
</div>
</section>
</div>
<div id="security">
<section id="section-6">
      <h2 id="name-security-considerations">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-6-1">The size of most types defined by Structured Fields is not limited; as a result, extremely large fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of individual fields as well as the overall header or trailer section size to mitigate such attacks.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">It is possible for parties with the ability to inject new HTTP fields to change the meaning
of a Structured Field. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3">The Display String type can convey any possible Unicode code point without sanitization; for example, they might contain unassigned code points, control points (including NUL), or noncharacters. Therefore, applications consuming Display Strings need to consider strategies such as filtering or escaping untrusted content before displaying it. See <span>[<a href="#PRECIS" class="cite xref">PRECIS</a>]</span> and <span>[<a href="#UNICODE-SECURITY" class="cite xref">UNICODE-SECURITY</a>]</span>.<a href="#section-6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-7">
      <h2 id="name-references">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-7.1">
        <h3 id="name-normative-references">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="HTTP">[HTTP]</dt>
        <dd>
<span class="refAuthor">Fielding, R., Ed.</span>, <span class="refAuthor">Nottingham, M., Ed.</span>, and <span class="refAuthor">J. Reschke, Ed.</span>, <span class="refTitle">"HTTP Semantics"</span>, <span class="seriesInfo">STD 97</span>, <span class="seriesInfo">RFC 9110</span>, <span class="seriesInfo">DOI 10.17487/RFC9110</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc9110">https://www.rfc-editor.org/rfc/rfc9110</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC0020">[RFC0020]</dt>
        <dd>
<span class="refAuthor">Cerf, V.</span>, <span class="refTitle">"ASCII format for network interchange"</span>, <span class="seriesInfo">STD 80</span>, <span class="seriesInfo">RFC 20</span>, <span class="seriesInfo">DOI 10.17487/RFC0020</span>, <time datetime="1969-10" class="refDate">October 1969</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc20">https://www.rfc-editor.org/rfc/rfc20</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4648">[RFC4648]</dt>
        <dd>
<span class="refAuthor">Josefsson, S.</span>, <span class="refTitle">"The Base16, Base32, and Base64 Data Encodings"</span>, <span class="seriesInfo">RFC 4648</span>, <span class="seriesInfo">DOI 10.17487/RFC4648</span>, <time datetime="2006-10" class="refDate">October 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc4648">https://www.rfc-editor.org/rfc/rfc4648</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="UTF8">[UTF8]</dt>
      <dd>
<span class="refAuthor">Yergeau, F.</span>, <span class="refTitle">"UTF-8, a transformation format of ISO 10646"</span>, <span class="seriesInfo">STD 63</span>, <span class="seriesInfo">RFC 3629</span>, <time datetime="2003-11" class="refDate">November 2003</time>, <span>&lt;<a href="http://www.rfc-editor.org/info/std63">http://www.rfc-editor.org/info/std63</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-7.2">
        <h3 id="name-informative-references">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="HPACK">[HPACK]</dt>
        <dd>
<span class="refAuthor">Peon, R.</span> and <span class="refAuthor">H. Ruellan</span>, <span class="refTitle">"HPACK: Header Compression for HTTP/2"</span>, <span class="seriesInfo">RFC 7541</span>, <span class="seriesInfo">DOI 10.17487/RFC7541</span>, <time datetime="2015-05" class="refDate">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc7541">https://www.rfc-editor.org/rfc/rfc7541</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9113">[HTTP/2]</dt>
        <dd>
<span class="refAuthor">Thomson, M., Ed.</span> and <span class="refAuthor">C. Benfield, Ed.</span>, <span class="refTitle">"HTTP/2"</span>, <span class="seriesInfo">RFC 9113</span>, <span class="seriesInfo">DOI 10.17487/RFC9113</span>, <time datetime="2022-06" class="refDate">June 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc9113">https://www.rfc-editor.org/rfc/rfc9113</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE754">[IEEE754]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for Floating-Point Arithmetic"</span>, <span class="seriesInfo">IEEE 754-2019</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2019.8766229</span>, <span class="seriesInfo">ISBN 978-1-5044-5924-2</span>, <time datetime="2019-07" class="refDate">July 2019</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/8766229">https://ieeexplore.ieee.org/document/8766229</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="PRECIS">[PRECIS]</dt>
        <dd>
<span class="refAuthor">Saint-Andre, P.</span> and <span class="refAuthor">M. Blanchet</span>, <span class="refTitle">"PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols"</span>, <span class="seriesInfo">RFC 8264</span>, <span class="seriesInfo">DOI 10.17487/RFC8264</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8264">https://www.rfc-editor.org/rfc/rfc8264</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5234">[RFC5234]</dt>
        <dd>
<span class="refAuthor">Crocker, D., Ed.</span> and <span class="refAuthor">P. Overell</span>, <span class="refTitle">"Augmented BNF for Syntax Specifications: ABNF"</span>, <span class="seriesInfo">STD 68</span>, <span class="seriesInfo">RFC 5234</span>, <span class="seriesInfo">DOI 10.17487/RFC5234</span>, <time datetime="2008-01" class="refDate">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc5234">https://www.rfc-editor.org/rfc/rfc5234</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7493">[RFC7493]</dt>
        <dd>
<span class="refAuthor">Bray, T., Ed.</span>, <span class="refTitle">"The I-JSON Message Format"</span>, <span class="seriesInfo">RFC 7493</span>, <span class="seriesInfo">DOI 10.17487/RFC7493</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc7493">https://www.rfc-editor.org/rfc/rfc7493</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8259">[RFC8259]</dt>
        <dd>
<span class="refAuthor">Bray, T., Ed.</span>, <span class="refTitle">"The JavaScript Object Notation (JSON) Data Interchange Format"</span>, <span class="seriesInfo">STD 90</span>, <span class="seriesInfo">RFC 8259</span>, <span class="seriesInfo">DOI 10.17487/RFC8259</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8259">https://www.rfc-editor.org/rfc/rfc8259</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="UNICODE-SECURITY">[UNICODE-SECURITY]</dt>
      <dd>
<span class="refAuthor">Davis, M.</span> and <span class="refAuthor">M. Suignard</span>, <span class="refTitle">"Unicode Security Considerations"</span>, <span class="seriesInfo">Unicode Technical Report #16</span>, <time datetime="2014-09-19" class="refDate">19 September 2014</time>, <span>&lt;<a href="http://www.unicode.org/reports/tr36/">http://www.unicode.org/reports/tr36/</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="faq">
<section id="appendix-A">
      <h2 id="name-frequently-asked-questions">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-frequently-asked-questions" class="section-name selfRef">Frequently Asked Questions</a>
      </h2>
<div id="why-not-json">
<section id="appendix-A.1">
        <h3 id="name-why-not-json">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-why-not-json" class="section-name selfRef">Why Not JSON?</a>
        </h3>
<p id="appendix-A.1-1">Earlier proposals for Structured Fields were based upon JSON <span>[<a href="#RFC8259" class="cite xref">RFC8259</a>]</span>. However, constraining its use to make it suitable for HTTP fields required senders and recipients to implement specific additional handling.<a href="#appendix-A.1-1" class="pilcrow">¶</a></p>
<p id="appendix-A.1-2">For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., <span>[<a href="#RFC7493" class="cite xref">RFC7493</a>]</span>), it cannot be relied upon.<a href="#appendix-A.1-2" class="pilcrow">¶</a></p>
<p id="appendix-A.1-3">Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.<a href="#appendix-A.1-3" class="pilcrow">¶</a></p>
<p id="appendix-A.1-4">Another example is JSON's ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it's necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it's likely that some field definition will find a need to violate it.<a href="#appendix-A.1-4" class="pilcrow">¶</a></p>
<p id="appendix-A.1-5">Because of JSON's broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability. In short, if it looks like JSON, people will be tempted to use a JSON parser/serializer on field values.<a href="#appendix-A.1-5" class="pilcrow">¶</a></p>
<p id="appendix-A.1-6">Since a major goal for Structured Fields is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serializer.<a href="#appendix-A.1-6" class="pilcrow">¶</a></p>
<p id="appendix-A.1-7">Additionally, there were widely shared feelings that JSON doesn't "look right" in HTTP fields.<a href="#appendix-A.1-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="implementation-notes">
<section id="appendix-B">
      <h2 id="name-implementation-notes">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-implementation-notes" class="section-name selfRef">Implementation Notes</a>
      </h2>
<p id="appendix-B-1">A generic implementation of this specification should expose the top-level serialize (<a href="#text-serialize" class="auto internal xref">Section 4.1</a>) and parse (<a href="#text-parse" class="auto internal xref">Section 4.2</a>) functions. They need not be functions; for example, it could be implemented as an object, with methods for each of the different top-level types.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<p id="appendix-B-2">For interoperability, it's important that generic implementations be complete and follow the algorithms closely; see <a href="#strict" class="auto internal xref">Section 1.1</a>. To aid this, a common test suite is being maintained by the community at &lt;https://github.com/httpwg/structured-field-tests&gt;.<a href="#appendix-B-2" class="pilcrow">¶</a></p>
<p id="appendix-B-3">Implementers should note that Dictionaries and Parameters are order-preserving maps. Some fields may not convey meaning in the ordering of these data types, but it should still be exposed so that it will be available to applications that need to use it.<a href="#appendix-B-3" class="pilcrow">¶</a></p>
<p id="appendix-B-4">Likewise, implementations should note that it's important to preserve the distinction between Tokens and Strings. While most programming languages have native types that map to the other types well, it may be necessary to create a wrapper "token" object or use a parameter on functions to assure that these types remain separate.<a href="#appendix-B-4" class="pilcrow">¶</a></p>
<p id="appendix-B-5">The serialization algorithm is defined in a way that it is not strictly limited to the data types defined in <a href="#types" class="auto internal xref">Section 3</a> in every case. For example, Decimals are designed to take broader input and round to allowed values.<a href="#appendix-B-5" class="pilcrow">¶</a></p>
<p id="appendix-B-6">Implementations are allowed to limit the size of different structures, subject to the minimums defined for each type. When a structure exceeds an implementation limit, that structure fails parsing or serialization.<a href="#appendix-B-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="abnf">
<section id="appendix-C">
      <h2 id="name-abnf">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-abnf" class="section-name selfRef">ABNF</a>
      </h2>
<p id="appendix-C-1">This section uses the Augmented Backus-Naur Form (ABNF) notation <span>[<a href="#RFC5234" class="cite xref">RFC5234</a>]</span> to illustrate expected syntax of Structured Fields. However, it cannot be used to validate their syntax, because it does not capture all requirements.<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<p id="appendix-C-2">This section is non-normative. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.<a href="#appendix-C-2" class="pilcrow">¶</a></p>
<div class="lang-abnf sourcecode" id="appendix-C-3">
<pre>
sf-list       = list-member *( OWS "," OWS list-member )
list-member   = sf-item / inner-list

inner-list    = "(" *SP [ sf-item *( 1*SP sf-item ) *SP ] ")"
                parameters

parameters    = *( ";" *SP parameter )
parameter     = param-key [ "=" param-value ]
param-key     = key
key           = ( lcalpha / "*" )
                *( lcalpha / DIGIT / "_" / "-" / "." / "*" )
lcalpha       = %x61-7A ; a-z
param-value   = bare-item

sf-dictionary = dict-member *( OWS "," OWS dict-member )
dict-member   = member-key ( parameters / ( "=" member-value ))
member-key    = key
member-value  = sf-item / inner-list

sf-item   = bare-item parameters
bare-item = sf-integer / sf-decimal / sf-string / sf-token
            / sf-binary / sf-boolean / sf-date / sf-displaystring

sf-integer       = ["-"] 1*15DIGIT
sf-decimal       = ["-"] 1*12DIGIT "." 1*3DIGIT
sf-string        = DQUOTE *( unescaped / "%" / bs-escaped ) DQUOTE
sf-token         = ( ALPHA / "*" ) *( tchar / ":" / "/" )
sf-binary        = ":" base64 ":"
sf-boolean       = "?" ( "0" / "1" )
sf-date          = "@" sf-integer
sf-displaystring = "%" DQUOTE *( unescaped / "\" / pct-encoded )
                   DQUOTE

base64       = *( ALPHA / DIGIT / "+" / "/" ) *"="

unescaped    = %x20-21 / %x23-24 / %x26-5B / %x5D-7E
bs-escaped   = "\" ( DQUOTE / "\" )

pct-encoded  = "%" lc-hexdig lc-hexdig
lc-hexdig = DIGIT / %x61-66 ; 0-9, a-f
</pre><a href="#appendix-C-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="changes">
<section id="appendix-D">
      <h2 id="name-changes-from-rfc-8941">
<a href="#appendix-D" class="section-number selfRef">Appendix D. </a><a href="#name-changes-from-rfc-8941" class="section-name selfRef">Changes from RFC 8941</a>
      </h2>
<p id="appendix-D-1">This revision of the Structured Field Values for HTTP specification has made the following changes:<a href="#appendix-D-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="appendix-D-2.1">
          <p id="appendix-D-2.1.1">Added the Date structured type. (<a href="#date" class="auto internal xref">Section 3.3.7</a>)<a href="#appendix-D-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-D-2.2">
          <p id="appendix-D-2.2.1">Stopped encouraging use of ABNF in definitions of new structured fields. (<a href="#specify" class="auto internal xref">Section 2</a>)<a href="#appendix-D-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-D-2.3">
          <p id="appendix-D-2.3.1">Moved ABNF to an informative appendix. (<a href="#abnf" class="auto internal xref">Appendix C</a>)<a href="#appendix-D-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-D-2.4">
          <p id="appendix-D-2.4.1">Added a "Structured Type" column to the HTTP Field Name Registry. (<a href="#iana" class="auto internal xref">Section 5</a>)<a href="#appendix-D-2.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-D-2.5">
          <p id="appendix-D-2.5.1">Refined parse failure handling. (<a href="#text-parse" class="auto internal xref">Section 4.2</a>)<a href="#appendix-D-2.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="appendix-D-2.6">
          <p id="appendix-D-2.6.1">Added the Display String structured type. (<a href="#displaystring" class="auto internal xref">Section 3.3.8</a>)<a href="#appendix-D-2.6.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="acknowledgements">
<section id="appendix-E">
      <h2 id="name-acknowledgements">
<a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="appendix-E-1">Many thanks to Matthew Kerwin for his detailed feedback and careful consideration during the development of this specification.<a href="#appendix-E-1" class="pilcrow">¶</a></p>
<p id="appendix-E-2">Thanks also to Ian Clelland, Roy Fielding, Anne van Kesteren, Kazuho Oku, Evert Pot, Julian Reschke, Martin Thomson, Mike West, and Jeffrey Yasskin for their contributions.<a href="#appendix-E-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-F">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Mark Nottingham</span></div>
<div dir="auto" class="left"><span class="org">Cloudflare</span></div>
<div dir="auto" class="left">
<span class="locality">Prahran</span> <span class="region">VIC</span> </div>
<div dir="auto" class="left"><span class="country-name">Australia</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:mnot@mnot.net" class="email">mnot@mnot.net</a>
</div>
<div class="url">
<span>URI:</span>
<a href="https://www.mnot.net/" class="url">https://www.mnot.net/</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Poul-Henning Kamp</span></div>
<div dir="auto" class="left"><span class="org">The Varnish Cache Project</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:phk@varnish-cache.org" class="email">phk@varnish-cache.org</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
